[{"state_before": "S : Type u\u2081\nL : Type u\u2082\nD : Type u\u2083\ninst\u271d\u2075 : Category.{v\u2081, u\u2081} S\ninst\u271d\u2074 : Category.{v\u2082, u\u2082} L\ninst\u271d\u00b3 : Category.{v\u2083, u\u2083} D\n\u03b9 : S \u2964 L\ninst\u271d\u00b2 : Full \u03b9\ninst\u271d\u00b9 : Faithful \u03b9\ninst\u271d : \u2200 (X : L), HasLimitsOfShape (StructuredArrow X \u03b9) D\nF : S \u2964 D\nX : S\n\u22a2 IsIso (limit.\u03c0 (diagram \u03b9 F (\u03b9.obj X)) (StructuredArrow.mk (\ud835\udfd9 (\u03b9.obj X))))", "expanded_tactic": "exact\n    <c> (f : X \u2245 Y) : IsIso f.hom</c>\n      ((<c> (F : J \u2964 C) [HasLimit F] : IsLimit (limit.cone F)</c> _).<c> {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) : s.pt \u2245 t.pt</c>\n        (<c> {X : J} (tX : IsInitial X) (F : J \u2964 C) :\n    IsLimit (coneOfDiagramInitial tX F) where\n  lift s</c> <c> [Full T] [Faithful T] : IsInitial (mk (\ud835\udfd9 (T.obj Y))) where\n  desc c</c> _))", "predictions0": ["suffices <c> (F : S \u2964 D) [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] ", "suffices <c> (F : S \u2964 D) [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    ", "suffices <c> (F : S \u2964 D) [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] :\n  ", "suffices <c> (F : S \u2964 D) [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOf", "suffices <c> (F : S \u2964 D) [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimi", "suffices <c> (F : S \u2964 D) [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [Has", "suffices <c> (F : S \u2964 D) [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [Fai", "suffices <c> (F : S \u2964 D) [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D]\n    [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] [HasLimitsOfShape (StructuredArrow X \u03b9) D] :\n    Is"], "predictions1": ["suffices <c> (f : X \u27f6 Y) : Prop where\n  \n  out : \u2203 inv : Y \u27f6 X, f \u226b inv = \ud835\udfd9 X \u2227 inv \u226b f = \ud835\udfd9 Y</c> (<c> (X : S) : StructuredArrow X \u03b9</c> X \u03b9) (<c> (X : S) : StructuredArrow X \u03b9</c> X \u03b9)", "suffices <c> (f : X \u27f6 Y) : Prop where\n  \n  out : \u2203 inv : Y \u27f6 X, f \u226b inv = \ud835\udfd9 X \u2227 inv \u226b f = \ud835\udfd9 Y</c> (<c> (X : S) : StructuredArrow X \u03b9</c> X \u03b9) (<c> (X : S) : StructuredArrow X \u03b9</c> X \u03b9) from <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>)", "suffices <c> (f : X \u27f6 Y) : Prop where\n  \n  out : \u2203 inv : Y \u27f6 X, f \u226b inv = \ud835\udfd9 X \u2227 inv \u226b f = \ud835\udfd9 Y</c> (<c> (X : S) : StructuredArrow X \u03b9</c> X \u03b9) (<c> (X : S) : StructuredArrow X \u03b9</c> X \u03b9) from <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "suffices <c> (f : X \u27f6 Y) : Prop where\n  \n  out : \u2203 inv : Y \u27f6 X, f \u226b inv = \ud835\udfd9 X \u2227 inv \u226b f = \ud835\udfd9 Y</c> (<c> (X : S) : StructuredArrow X \u03b9</c> X \u03b9) (<c> (X : S) : StructuredArrow X \u03b9</c> X \u03b9) (<c> (X : S) : StructuredArrow X \u03b9</c> X \u03b9)", "suffices <c> (f : X \u27f6 Y) : Prop where\n  \n  out : \u2203 inv : Y \u27f6 X, f \u226b inv = \ud835\udfd9 X \u2227 inv \u226b f = \ud835\udfd9 Y</c> (<c> (X : S) : StructuredArrow X \u03b9</c> X \u03b9) (<c> (X : S) : StructuredArrow X \u03b9</c> X \u03b9) from <c> {\u03b1 : Sort u} [i : \u03b1] : \u03b1</c>)", "suffices <c> (f : X \u27f6 Y) : Prop where\n  \n  out : \u2203 inv : Y \u27f6 X, f \u226b inv = \ud835\udfd9 X \u2227 inv \u226b f = \ud835\udfd9 Y</c> (<c> (X : S) : StructuredArrow X \u03b9</c> X \u03b9) (<c> (X : S) : StructuredArrow X \u03b9</c> X \u03b9) (<c> (X : S) : StructuredArrow X \u03b9</c> X \u03b9) from <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "suffices <c> (f : X \u27f6 Y) : Prop where\n  \n  out : \u2203 inv : Y \u27f6 X, f \u226b inv = \ud835\udfd9 X \u2227 inv \u226b f = \ud835\udfd9 Y</c> (<c> (X : S) : StructuredArrow X \u03b9</c> X \u03b9) (<c> (X : S) : StructuredArrow X \u03b9</c> X \u03b9) (<c> (X : S) : StructuredArrow X \u03b9</c> X \u03b9) from <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>)", "suffices <c> (f : X \u27f6 Y) : Prop where\n  \n  out : \u2203 inv : Y \u27f6 X, f \u226b inv = \ud835\udfd9 X \u2227 inv \u226b f = \ud835\udfd9 Y</c> (<c> (X : S) : StructuredArrow X \u03b9</c> X \u03b9) (<c> (X : S) : StructuredArrow X \u03b9</c> X \u03b9) (<c> (X : S) : StructuredArrow X \u03b9</c> X \u03b9) (<c> (X : S) : StructuredArrow X \u03b9</c> X \u03b9)"], "predictions2": ["exact <c> {\u03b1 : Sort u} [i : \u03b1] : \u03b1</c>", "exact <c> {\u03b1 : Sort u} [i : \u03b1] : \u03b1</c> (<c> {\u03b1 : Sort u} [i : \u03b1] : \u03b1</c> X)", "exact <c> {\u03b1 : Sort u} [i : \u03b1] : \u03b1</c> (<c> {\u03b1 : Sort u} [i : \u03b1] : \u03b1</c> _)", "exact <c> (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : IsIso (f \u226b g) \u2194 IsIso f</c> (<c> (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : IsIso f \u2194 ", "exact <c> (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : IsIso (f \u226b g) \u2194 IsIso f</c> (<c> (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : \u03b1.inv \u226b f = g \u2194 f = ", "exact <c> (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : IsIso f \u2194 IsIso g \u2192 IsIso f</c> (<c> (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : IsIso f \u2194 ", "exact <c> (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : IsIso (f \u226b g) \u2194 IsIso f</c> _ (<c> (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : IsIso f \u2194 ", "exact <c> (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : IsIso f \u2194 IsIso f \u2194 IsIso g</c> (<c> (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : IsIso f \u2194 "]}, {"state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns t u : Finset \u03b1\nP\u271d : Finpartition s\na : \u03b1\nP : Finpartition s\n\u22a2 P.parts.card \u2264 \u22a5.parts.card", "expanded_tactic": "exact <c> {a : \u03b1} {P Q : Finpartition a} (h : P \u2264 Q) : Q.parts.card \u2264 P.parts.card</c> <a>bot_le</a>", "predictions0": ["exact <c> : s.card \u2264 \u22a5</c>", "exact <c> : a \u2264 \u22a5</c>", "exact <c> : s.card \u2264 s.card</c>", "exact <c> : s.card \u2264 \u22a5.card</c>", "simp", "exact <c> (s : Finset \u03b1) : s.card \u2264 \u22a5</c>", "exact <c> (s : Finset \u03b1) : s.card \u2264 s.card</c>", "exact <c> (P : Finpartition s) : P.card \u2264 P.card</c>"], "predictions1": ["exact <c> (s : Finset \u03b1) : s.card \u2264 \u22a5</c>", "exact <c> : s.card \u2264 \u22a5</c>", "exact <c> (s : Finset \u03b1) : s.card \u2264 s.card</c> _", "exact <c> (s : Finset \u03b1) : s.card \u2264 \u22a5</c> _", "exact <c> (s : Finset \u03b1) : s \u2286 \u2205</c>", "exact <c> : s.card \u2264 s.card</c>", "exact <c> : a \u2264 \u22a5</c>", "exact <c> (s : Finset \u03b1) : s.card \u2264 s.card</c>"], "predictions2": ["exact <c> : a \u2264 \u22a5</c>", "exact <c> (s : Finset \u03b1) : s \u2286 \u2205</c> _", "exact <c> : a \u2264 a</c>", "exact <c> (s : Finset \u03b1) : s.card \u2264 \u22a5</c> _", "exact <c> : b \u2264 a \u2294 b</c>", "exact <c> (a : \u03b1) : a \u2264 \u22a5</c> _", "exact <c> : a \u2293 b \u2264 a</c>", "exact <c> (s : Finset \u03b1) : s.card \u2264 s.card</c> _"]}, {"state_before": "\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\ns : Finset \u03b1\nf : \u03b1 \u2192 R\ng : \u03b1 \u2192 M\nhf : \u2200 (a : \u03b1), f a \u2260 0 \u2192 a \u2208 s\n\u22a2 \u2200 x \u2208 s, f x \u2022 g x \u2260 0 \u2192 f x \u2260 0", "expanded_tactic": "intro x _ h", "predictions0": ["exact fun x _ hx => (hf x hx).<a>symm</a>", "simp_rw [<c> {f : \u03b1 \u2192 M} {s : Finset \u03b1} (hf : \u2200 a, f a \u2260 0 \u2192 a \u2208 s) : f \u2022 g a = 0</c> hf]", "simp_rw [<c> {f : \u03b1 \u2192 M} {s : Finset \u03b1} (hf : \u2200 a \u2208 s, f a \u2260 0) :\n    \u2200 a \u2208 s, f a \u2022 g a = 0</c> hf]", "simp_rw [<c> {f : \u03b1 \u2192 M} {s : Finset \u03b1} (hf : \u2200 x \u2208 s, f x \u2260 0) :\n    \u2200 x \u2208 s, f x \u2260 0 \u2192 f x = 0</c> hf]", "simp_rw [<c> {f : \u03b1 \u2192 M} {s : Finset \u03b1} (hf : \u2200 x \u2208 s, f x \u2260 0) :\n    \u2200 x \u2208 s, f x \u2260 0 \u2192 f x \u2260 0</c> hf]", "simp_rw [<c> {f : \u03b1 \u2192 M} {s : Finset \u03b1} (hf : \u2200 a \u2208 s, f a \u2260 0) :\n    \u2200 a \u2208 s, f a \u2260 0 \u2192 f a = 0</c> hf]", "simp_rw [<c> {f : \u03b1 \u2192 M} {s : Finset \u03b1} (hf : \u2200 x \u2208 s, f x \u2260 0) :\n    \u2200 x \u2208 s, f x \u2022 g x \u2260 0 \u2192 f x = 0</c> hf]", "simp_rw [<c> {f : \u03b1 \u2192 M} {s : Finset \u03b1} (hf : \u2200 x \u2208 s, f x \u2260 0) :\n    \u2200 x \u2208 s, f x \u2022 g x \u2260 0 \u2192 f x \u2260 0</c> hf]"], "predictions1": ["aesop", "exact fun x _ hx => <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "exact fun x _ hx => <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> (hf x hx)", "exact fun x _ hx hg => <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "exact fun x _ hx hg => <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> (hf x hx)", "exact fun x _ hx => <c> {\u03b1 : Sort u} {p : \u03b1 \u2192 Prop} (h : \u2203 x, p x) : p (choose h)</c> hx", "exact fun x _ hx => <c> {\u03b1 : Sort u} {p : \u03b1 \u2192 Prop} (h : \u2203 x, p x) : p (choose h)</c> (hf x hx)", "exact fun x _ hx => <c> {\u03b1 : Sort u} {p : \u03b1 \u2192 Prop} (h : \u2203 x, p x) : p (choose h)</c> (hf _ hx)"], "predictions2": ["intro x _ hx", "intro x _ H", "exact fun x _ hx => (hf x hx).<c> {C : Sort u} (h : False) : C</c>", "exact fun x _ hx => <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> (hf x hx)", "exact fun a _ ha => (hf _ ha).<c> {C : Sort u} (h : False) : C</c>", "exact fun _ _ hx => <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "exact fun x _ hx => (hf x hx).<c>'</c>", "exact fun x _ hx => <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>"]}, {"state_before": "\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : IsDomain R\ninst\u271d\u2075 : IsPrincipalIdealRing R\nM\u271d : Type u_3\ninst\u271d\u2074 : AddCommGroup M\u271d\ninst\u271d\u00b3 : Module R M\u271d\nb : \u03b9 \u2192 M\u271d\ninst\u271d\u00b2 : Finite \u03b9\nO : Type u_4\ninst\u271d\u00b9 : AddCommGroup O\ninst\u271d : Module R O\nM N : Submodule R O\nb'M : Basis \u03b9 R \u21a5M\nN_bot : N \u2260 \u22a5\nN_le_M : N \u2264 M\nthis : \u2203 \u03d5, \u2200 (\u03c8 : \u21a5M \u2192\u2097[R] R), \u00acLinearMap.submoduleImage \u03d5 N < LinearMap.submoduleImage \u03c8 N\n\u03d5 : \u21a5M \u2192\u2097[R] R := Exists.choose this\n\u03d5_max : \u2200 (\u03c8 : \u21a5M \u2192\u2097[R] R), \u00acLinearMap.submoduleImage (Exists.choose this) N < LinearMap.submoduleImage \u03c8 N\na : R := generator (LinearMap.submoduleImage \u03d5 N)\na_mem : a \u2208 LinearMap.submoduleImage \u03d5 N\na_zero : \u00aca = 0\ny : O\nyN : y \u2208 N\n\u03d5y_eq : \u03d5 { val := y, property := \u22ef } = a\n_\u03d5y_ne_zero : \u03d5 { val := y, property := \u22ef } \u2260 0\nc : \u03b9 \u2192 R\nhc : \u2200 (i : \u03b9), (Basis.coord b'M i) { val := y, property := \u22ef } = a * c i\nval\u271d : Fintype \u03b9\ny' : O := \u2211 i : \u03b9, c i \u2022 \u2191(b'M i)\ny'M : y' \u2208 M\nmk_y' : { val := y', property := y'M } = \u2211 i : \u03b9, c i \u2022 b'M i\n\u22a2 \u2211 x : \u03b9, a \u2022 c x \u2022 b'M x = \u2211 i : \u03b9, (b'M.repr { val := y, property := \u22ef }) i \u2022 b'M i", "expanded_tactic": "refine' <a>Finset.sum_congr</a> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun i _ \u21a6 _", "predictions0": ["congr", "refine' <a>Finset.sum_congr</a> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun i _ => _", "apply <a>Finset.sum_congr</a> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "congr with i", "refine' <a>Finset.sum_congr</a> <a>rfl</a> fun i _ => _", "refine <a>Finset.sum_congr</a> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun i _ \u21a6?_", "refine' <a>Finset.sum_congr</a> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun i _ \u21a6 _", "congr 1 with i : 1"], "predictions1": ["refine' <a>Finset.sum_congr</a> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun i _ => _", "apply <a>Finset.sum_congr</a> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "refine' <a>Finset.sum_congr</a> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun i _hi => _", "refine <a>Finset.sum_congr</a> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun i _ =>?_", "refine <a>Finset.sum_congr</a> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun i _ \u21a6?_", "refine' <a>sum_congr</a> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun i _ => _", "refine' <a>Finset.sum_congr</a> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun x _ => _", "apply <a>sum_congr</a> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>"], "predictions2": ["refine' <a>sum_congr</a> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun i _ => _", "apply <a>sum_congr</a> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "refine' <a>sum_congr</a> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun i hi => _", "refine' <a>Finset.sum_congr</a> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun i _ => _", "refine' <a>sum_congr</a> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun _ _ => _", "refine' <a>sum_congr</a> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun i => _", "refine' <a>sum_congr</a> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun i _ \u21a6 _", "refine <a>sum_congr</a> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun i _ =>?_"]}, {"state_before": "C\u271d : Type u\u2081\ninst\u271d\u00b9\u2070 : Category.{v\u2081, u\u2081} C\u271d\ninst\u271d\u2079 : MonoidalCategory C\u271d\ninst\u271d\u2078 : BraidedCategory C\u271d\nD : Type u\u2082\ninst\u271d\u2077 : Category.{v\u2082, u\u2082} D\ninst\u271d\u2076 : MonoidalCategory D\ninst\u271d\u2075 : BraidedCategory D\nE : Type u\u2083\ninst\u271d\u2074 : Category.{v\u2083, u\u2083} E\ninst\u271d\u00b3 : MonoidalCategory E\ninst\u271d\u00b2 : BraidedCategory E\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d : MonoidalCategory C\ni : SymmetricCategory C\n\u22a2 reverseBraiding C = toBraidedCategory", "expanded_tactic": "dsimp only [<c> : BraidedCategory C where\n  braiding X Y</c>]", "predictions0": ["ext", "refine' <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> _", "refine' <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun x => _", "refine' <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun X => _", "refine' <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> (<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>)", "refine' <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun \u03b1 \u03b2 => _", "simp only [<c> : BraidedCategory C where\n  toBraidedCategory</c>]", "refine' <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> (<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> _)"], "predictions1": ["dsimp [<c> : BraidedCategory C</c>]", "dsimp [<c> : C \u2964 Type u</c>]", "dsimp [<c> : BraidedCategory C \u2964 Type w</c>]", "dsimp [<c> : BraidedCategory C \u2964 Type u</c>]", "dsimp [<c> : BraidedCategory C \u2964 C where\n  obj</c>]", "dsimp [<c> : BraidedCategory C \u2964 C where\n  obj X</c>]", "dsimp [<c> : BraidedCategory C \u2964 C where\n  obj C</c>]", "dsimp [<c> : BraidedCategory C</c>, <c> : BraidedCategory C</c>]"], "predictions2": ["dsimp [<c> : BraidedCategory C</c>]", "dsimp [<c> : C \u2964 C where\n  obj X</c>]", "dsimp [<c> : BraidedCategory C \u2964 Type w</c>]", "dsimp [<c> : BraidedCategory C where\n  obj X</c>]", "dsimp [<c> : BraidedCategory C \u2245 BraidedCategory D</c>]", "dsimp [<c> : BraidedCategory C \u2964 Type where\n  obj X</c>]", "dsimp [<c> : BraidedCategory C \u2964 C where\n  obj X</c>]", "dsimp [<c> : BraidedCategory C</c>, <c> : BraidedCategory C</c>]"]}, {"state_before": "case h.mk.mpr\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny : M\nf : E \u2192\u2097.[R] F\nz : M\nx_fst : E\nx_snd : F\nh : \u2203 y \u2208 graph f, (LinearMap.prodMap LinearMap.id (z \u2022 LinearMap.id)) y = (x_fst, x_snd)\n\u22a2 (x_fst, x_snd) \u2208 graph (z \u2022 f)", "expanded_tactic": "rcases h with \u27e8x', hx', h\u27e9", "predictions0": ["rcases h with \u27e8y, hy, h\u27e9", "rcases h with \u27e8y, hy, rfl\u27e9", "rcases h with \u27e8y, h1, h2\u27e9", "obtain \u27e8y, hy, h\u27e9 := h", "rcases h with \u27e8y, hy, eq\u27e9", "obtain \u27e8y, hy, rfl\u27e9 := h", "rcases h with \u27e8y, hy, hz\u27e9", "cases' h with h h"], "predictions1": ["rcases h with \u27e8y, hy, h\u27e9", "rcases h with \u27e8x', hx', hy'\u27e9", "simp only [<c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>, <c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>] at h", "simp only [<a>LinearMap.prodMap_apply</a>, <c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>, <c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>] at h", "simp only [<c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>, <c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>, <c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>] at h", "simp only [<a>LinearMap.prodMap_apply</a>, <c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>, <c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>, <c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>] at h", "simp only [<c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>, <c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>, <c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>, <c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>] at h", "simp only [<a>LinearMap.prodMap_apply</a>, <c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>, <c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>, <c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>, <c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>] at h"], "predictions2": ["simp only [<c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>, <a>LinearMap.id_apply</a>, <a>Prod.mk.inj_iff</a>] at h", "simp only [<c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>, <a>Prod.mk.inj_iff</a>, <a>Prod.mk.inj_iff</a>] at h", "simp only [<c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>, <a>LinearMap.id_apply</a>, <a>Prod.smul_mk</a>, <a>smul_eq_mul</a>] at ", "simp only [<c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>, <c> (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (x : M) : f.prodMap g x = f", "simp only [<c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>, <c> (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (x : M) : (f \u2218 id : ", "simp only [<c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>, <a>LinearMap.id_apply</a>, <a>Prod.mk.inj_iff</a>, <a>Prod.mk.inj_i", "simp only [<c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>, <c> (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (x : M) : f.prodMap g x = f (g x)</c", "simp only [<c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>, <a>LinearMap.id_apply</a>, <a>Prod.smul_mk</a>, <a>smul_eq_mul</a>] at h"]}, {"state_before": "case h.right\nC : Type u\ninst\u271d : Category.{v, u} C\nX : C\nS : Sieve X\nW : C\nx : FamilyOfElements (yoneda.obj W) S.arrows\nhx : FamilyOfElements.Compatible x\nH : IsColimit (cocone S.arrows)\ns : Cocone (diagram S.arrows) := compatibleYonedaFamily_toCocone S.arrows W x hx\n\u22a2 \u2200 (y : (yoneda.obj W).obj (op X)), (fun t => FamilyOfElements.IsAmalgamation x t) y \u2192 y = H.desc s", "expanded_tactic": "exact fun g hg => H.uniq s g (fun \u27e8\u27e8f, _, hom\u27e9, hf\u27e9 => hg hom hf)", "predictions0": ["intro y hy", "intro t ht", "rintro y \u27e8hy\u27e9", "rintro \u27e8t, ht\u27e9 ht'", "exact fun y hy => (H.eq_of_compatibleYonedaFamily_toCocone hx hy).<a>Eq.symm</a>", "exact fun y hy \u21a6 (H.eq_of_compatibleYonedaFamily_toCocone hx hy).<a>Eq.symm</a>", "exact fun y hy \u21a6 (H.eq_of_compatibleYonedaFamily_toCocone hy).<a>Eq.symm</a>", "exact fun y hy \u21a6 (<c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : f = g \u2194 f = h</c> hy).<a>Eq.symm</a>"], "predictions1": ["intro y hy", "rintro \u27e8t, ht\u27e9 ht'", "exact fun y hy \u21a6 <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "exact fun y hy \u21a6 <c> {\u03b1 : Sort u} {p : \u03b1 \u2192 Prop} {a : \u03b1} : Eq a a</c>", "exact fun y hy \u21a6 <c> {\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {f g : (x : \u03b1) \u2192 \u03b2 x}\n    (h : \u2200 x, f x = g x) : f = g</c> hy", "exact fun y hy \u21a6 <c> {\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {f g : (x : \u03b1) \u2192 \u03b2 x}\n    (h : \u2200 x, f x = g x) : f = g</c> fun _ => H.desc s", "exact fun y hy \u21a6 <c> {\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {f g : (x : \u03b1) \u2192 \u03b2 x}\n    (h : \u2200 x, f x = g x) : f = g</c> fun _ => <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "exact fun y hy \u21a6 <c> {\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {f g : (x : \u03b1) \u2192 \u03b2 x}\n    (h : \u2200 x, f x = g x) : f = g</c> fun _ \u21a6 H.desc s"], "predictions2": ["exact fun y hy \u21a6 <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "exact fun y hy \u21a6 (<c> (x : FamilyOfElements P X) : x.IsAmalgamation \u2194 \u2200 y : FamilyOfElements P, IsAmalgamation x</c> _ _ _).1 H", "exact fun y hy \u21a6 (<c> (x : FamilyOfElements P X) : x.IsAmalgamation \u2194 \u2200 y : FamilyOfElements P, IsAmalgamation y</c> _ _ _).1 H", "exact fun y hy \u21a6 (<c> (x : FamilyOfElements P X) : x.IsAmalgamation \u2194 \u2200 y : FamilyOfElements P, IsAmalgamation x y</c> _ _ _).1 H", "exact fun y hy \u21a6 (<c> (x : FamilyOfElements P X) : x.IsAmalgamation \u2194 \u2200 y : FamilyOfElements P, IsAmalgamation x</c> _ _ _).1 (hy _ hy)", "exact fun y hy \u21a6 (<c> (x : FamilyOfElements P X) : x.IsAmalgamation \u2194 \u2200 y : FamilyOfElements P, IsAmalgamation x y</c> _ _ _).1 (hy _ hy)", "exact fun y hy \u21a6 (<c> (x : FamilyOfElements P X) : x.IsAmalgamation \u2194 \u2200 y : FamilyOfElements P, IsAmalgamation x</c> y hy).1 (by simp)", "exact fun y hy \u21a6 (<c> (x : FamilyOfElements P X) : x.IsAmalgamation \u2194 \u2200 y : FamilyOfElements P, IsAmalgamation x</c> _ _ _).1 (hy s hy)"]}, {"state_before": "F : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\nS : Set E\n\u03b1 : E\nK : Type u_3\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\ninst\u271d\u00b9 : Algebra E K\ninst\u271d : IsScalarTower F E K\nL : IntermediateField F K\nhalg : Algebra.IsAlgebraic F E \u2228 Algebra.IsAlgebraic F \u21a5L\ni : E \u2192\u2090[F] K := IsScalarTower.toAlgHom F E K\nE' : IntermediateField F K := AlgHom.fieldRange i\ni' : E \u2243\u2090[F] \u21a5E' := AlgEquiv.ofInjectiveField i\nhi : \u21d1(algebraMap E K) = \u21d1(algebraMap (\u21a5E') K) \u2218 \u21d1i'\n\u22a2 (adjoin E \u2191L).toSubalgebra = Algebra.adjoin E \u2191L", "expanded_tactic": "apply_fun _ using <c> :\n    Function.Injective (restrictScalars R : Subalgebra S A \u2192 Subalgebra R A)</c> F", "predictions0": ["exact <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "apply <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "exact <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> (<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>)", "exact <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> (<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> _)", "exact <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> (<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> hi)", "rw [\u2190 <c> : adjoin E (L : IntermediateField F K) = adjoin E (L : IntermediateField F K)</c>, hi]", "rw [\u2190 <c> : adjoin E (L : IntermediateField F E) = adjoin E (L : IntermediateField F E)</c>, hi]", "exact <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> (<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> (<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>))"], "predictions1": ["apply <c></c>", "apply <c> : \u2200 {a b : \u03b1}, a \u2264 b \u2192 b \u2264 a \u2192 a = b</c>", "apply <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "apply <c> {\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {f g : (x : \u03b1) \u2192 \u03b2 x}\n    (h : \u2200 x, f x = g x) : f = g</c>", "refine <c> : \u2200 {a b : \u03b1}, a \u2264 b \u2192 b \u2264 a \u2192 a = b</c> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun x \u21a6?_", "refine <c> : \u2200 {a b : \u03b1}, a \u2264 b \u2192 b \u2264 a \u2192 a = b</c> <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun x \u21a6?_)", "have hi' : <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R \u2192+* A</c> E (E' : <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R \u2192+* A</c> E K) = <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R \u2192+* A</c> E (E' : <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R \u2192+* A</c> E K) = <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R \u2192+* A</c> E (E' : <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R \u2192+* A</c> E K) = <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R \u2192+* A</c> E (E' : <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R \u2192+* A</c> E K) := by\n    rw [\u2190 <c> {R S} [CommSemiring R] [CommSemiring S] [CommSemiring S]\n    [Algebra R S] [Algebra R S] [Algebra R S] [Algebra R S] [Algebra R S] [Algebra R S] [Algebra R S]\n    [IsScalarTower R S A] [IsScalarTower R S A] : R ", "have hi' : <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R \u2192+* A</c> E (E' : <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R \u2192+* A</c> E K) = <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R \u2192+* A</c> E (E' : <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R \u2192+* A</c> E K) = <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R \u2192+* A</c> E (E' : <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R \u2192+* A</c> E K) = <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R \u2192+* A</c> E (E' : <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R \u2192+* A</c> E K) := by\n    rw [\u2190 <c> {R S} [CommSemiring R] [CommSemiring S] [CommSemiring S]\n    [Algebra R S] [Algebra R S] [Algebra R S] [Algebra R S] [Algebra R S] [Algebra R S] [Algebra R S] [Algebra R S]\n    [IsScalarTower R S A] [IsScalarTowe"], "predictions2": ["apply <c> : \u2200 {a b : \u03b1}, a \u2264 b \u2192 b \u2264 a \u2192 a = b</c>", "rw [<c> : adjoin F (S : Set E) = S</c>]", "rw [<c> : adjoin R s = Subalgebra.toSubalgebra</c>]", "rw [<c> : adjoin R s = \u22a4 \u2194 \u22a4 \u2264 a</c>]", "rw [<c> : adjoin R s = \u22a4 \u2194 \u22a4 \u2264 adjoin R s</c>]", "refine' <c> : \u2200 {a b : \u03b1}, a \u2264 b \u2192 b \u2264 a \u2192 a = b</c> _ (<c> (h : a \u2264 b) : b \u2264 a</c> _)", "refine' <c> : \u2200 {a b : \u03b1}, a \u2264 b \u2192 b \u2264 a \u2192 a = b</c> _ (<c> (h : a \u2264 b) : b - a + a = b</c> _)", "refine' <c> : \u2200 {a b : \u03b1}, a \u2264 b \u2192 b \u2264 a \u2192 a = b</c> _ (<c> (f : \u03b1 \u2192+* \u03b2) : f '' univ \u2264 range f</c> _)"]}, {"state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_2\n\u03c0 : \u03b9 \u2192 Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 AntitoneOn (\u21d1toDual \u2218 f \u2218 \u21d1ofDual) s \u2194 AntitoneOn f s", "expanded_tactic": "rw [<c> : AntitoneOn (toDual \u2218 f : \u03b1 \u2192 \u03b2\u1d52\u1d48) s \u2194 MonotoneOn f s</c>, <c> : MonotoneOn (f \u2218 ofDual) s \u2194 AntitoneOn f s</c>]", "predictions0": ["rfl", "rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn (foDual \u2218 f \u2218 ofDual) s \u2194 AntitoneOn f s</c>]", "rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn (foDual \u2218 f \u2218 ofDual) s \u2194 AntitoneOn (foDual \u2218 f \u2218 ofDual) s</c>]", "rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn f s \u2194 AntitoneOn f s</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn f s</c>]", "rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn f s \u2194 AntitoneOn f s</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn f s \u2194 AntitoneOn f s</c>]", "rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn f s \u2194 AntitoneOn (f \u2218 ofDual) s</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn f s \u2194 AntitoneOn f s</c>]", "rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn f s \u2194 AntitoneOn f s</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn f s \u2194 AntitoneOn (f \u2218 ofDual) s</c>]", "rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn f s \u2194 AntitoneOn f s</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn (foDual \u2218 f \u2218 ofDual) s \u2194 AntitoneOn f s</c>]"], "predictions1": ["rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : AntitoneOn f s \u2194 AntitoneOn f s</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : AntitoneOn f s</c>]", "rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n  AntitoneOn f s \u2194 AntitoneOn f s</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn (toDual \u2218 f \u2218 ofDual) s \u2194 AntitoneOn f s</c>]", "rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n  AntitoneOn (toDual \u2218 f \u2218 ofDual) s \u2194 AntitoneOn f s</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn (toDual \u2218 f \u2218 ofDual) s \u2194 AntitoneOn f s</c>]", "rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n  AntitoneOn (toDual \u2218 f \u2218 ofDual) s \u2194 AntitoneOn f s</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn f s \u2194 AntitoneOn f s</c>]", "rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n  AntitoneOn (toDual \u2218 f \u2218 ofDual) s \u2194 AntitoneOn f s</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n  AntitoneOn f s \u2194 AntitoneOn f s</c>]", "rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn (toDual \u2218 f \u2218 ofDual) s \u2194 AntitoneOn f s</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn f s \u2194 AntitoneOn f s</c>]", "rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n  AntitoneOn (toDual \u2218 f \u2218 ofDual) s \u2194 AntitoneOn f s</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn f s \u2194 AntitoneOn (f \u2218 ofDual) s</c>]", "rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n  AntitoneOn (toDual \u2218 f \u2218 ofDual) s \u2194 AntitoneOn f s</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn (toDual \u2218 f \u2218 ofDual) s \u2194 AntitoneOn (f \u2218 ofDual) s</c>]"], "predictions2": ["rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop</c>]", "rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop</c>, <c> {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)</c>]", "rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop</c>]", "rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn f s \u2194 AntitoneOn f s</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop</c>]", "rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn (toDual \u2218 f \u2218 ofDual) s \u2194 AntitoneOn f s</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop</c>]", "rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b2) : Prop</c>]", "rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn (toDual \u2218 f \u2218 ofDual) s \u2194 AntitoneOn f s</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : f \u2218 ofDual ", "rw [<c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn (toDual \u2218 f \u2218 ofDual) s \u2194 AntitoneOn f s</c>, <c> (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    AntitoneOn (f"]}, {"state_before": "case mk\nC : Type u_1\ninst\u271d : Category.{u_2, u_1} C\nn m : \u2115\nF\u271d G\u271d : ComposableArrows C n\nF G : ComposableArrows C (n + 1)\nh\u2080 : obj' F 0 \u22ef = obj' G 0 \u22ef\nh : \u03b4\u2080 F = \u03b4\u2080 G\nw : map' F 0 1 \u22ef \u22ef = eqToHom h\u2080 \u226b map' G 0 1 \u22ef \u22ef \u226b eqToHom \u22ef\nthis : \u2200 (i : Fin (n + 1 + 1)), F.obj i = G.obj i\ni : \u2115\nhi : i < n + 1 + 1\n\u22a2 (homMkSucc (eqToHom h\u2080) (eqToHom h) \u22ef).app { val := i, isLt := hi } = eqToHom \u22ef", "expanded_tactic": "cases' i with i", "predictions0": ["cases i", "dsimp", "cases' i with i hi", "cases' i with i", "dsimp [<c> : ComposableArrows C n</c>]", "dsimp [<c> : ComposableArrows C n \u2192 ComposableArrows C n</c>]", "dsimp [<c> : ComposableArrows C n where\n  toFun</c>]", "dsimp [<c> : ComposableArrows C n where\n  toFun i</c>]"], "predictions1": ["cases' i with i hi", "cases i <;> omega", "dsimp [<c> {n m : Nat} (h : n < m) : Fin (n + 1)</c>]", "dsimp [<c> {n m : Nat} (h : n < m) : Fin (n + 1)</c>] at hi", "simp only [<c> (F : ComposableArrows C n) (G : ComposableArrows C (n + 1)) (i : Fin (n + 1)) (hi : i < n) :\n    F.map' 0 1 (by simpa using hi) = F.map' 0 1 (by simpa using hi)</c>]", "simp only [<c> (F G : ComposableArrows C n) (G : ComposableArrows C (n + 1)) (i : Fin (n + 1)) (hi : i < n) :\n    F.map' 0 1 (by simpa using hi) = F.map' 0 1 (by simpa using hi)</c>]", "simp only [<c> (F G : ComposableArrows C n) (G : ComposableArrows C (n + 1)) (i : Fin (n + 1)) (hi : i < n) :\n    F.map' 0 1 (by simpa using hi) = eqToHom (by simpa using hi)</c>]", "simp only [<c> (F : ComposableArrows C n) (G : ComposableArrows C (n + 1)) (i : Fin (n + 1)) (hi : i < n) :\n    F.map' 0 1 (by simpa using hi) = F.map' 0 1 (by simpa using hi)</c>, <c> (F : ComposableArrows C n) (G : ComposableArrows C (n + 1)) (i : Fin (n + 1)) :\n    F.map' 0 1 (by simpa using hi) = F.map' 0 1 (by simpa using hi)</c>]"], "predictions2": ["cases' i with i hi", "cases i <;> simp [<c> {n m : Nat} (h : n < m) : succ n \u2264 m</c> hi]", "simp only [<c> {n m : Nat} (h : n < m) : succ n \u2264 m</c>]", "simp only [<c> {n m : Nat} (h : n < m) : succ n \u2264 m</c>] at hi", "simp only [<c> {n m : Nat} (h : n < m) : succ n \u2264 m</c> hi]", "dsimp [<c> {n m : Nat} (h : n < m) : succ n \u2264 m</c>] at hi", "dsimp [<c> {n m : Nat} (h : n < m) : succ n \u2264 m</c>]", "cases' <c> {a b : \u03b1} : a < b \u2192 a \u2264 b \u2228 a = b</c> hi with h' h'"]}, {"state_before": "R : Type u\ninst\u271d\u00b9 : CommSemiring R\nS : Type v\ninst\u271d : CommSemiring S\nf g : R[X]\nh : Separable (f * g)\nthis : IsCoprime f (derivative f * g + f * derivative g)\n\u22a2 IsCoprime f g", "expanded_tactic": "exact <c> (H : IsCoprime x (y * z)) : IsCoprime x z</c> (<c> (h : IsCoprime x (y + x * z)) : IsCoprime x y</c> this)", "predictions0": ["exact <c> {f g : R[X]} (h : Separable (f * g)) : IsCoprime f g</c> this", "rwa [<c> : IsCoprime f (derivative f) + f * derivative g</c>, <c> : IsCoprime f (derivative f) + f * derivative g</c>] at this", "rwa [<c> : IsCoprime f (derivative f) + f * derivative g + f * derivative g</c>, <c> : IsCoprime f (derivative f) + f * derivative g</c>] at this", "rwa [<c> : IsCoprime f (derivative f) + f * derivative g</c>, <c> : IsCoprime f (derivative f) + f * derivative g</c>, <c> : IsCoprime f (derivative f) + f * derivative g</c>] at this", "rwa [<c> : IsCoprime f (derivative f) + f * derivative g</c>, <c> : IsCoprime f (derivative f) + f * derivative g</c>, <c> : IsCoprime f g \u2194 IsCoprime f g</c>] at this", "rwa [<c> : IsCoprime f (derivative f * g) + f * derivative g</c>, <c> : IsCoprime f (derivative f) + f * derivative g</c>, <c> : IsCoprime f (derivative f) + f * derivative g</c>] at this", "rwa [<c> : IsCoprime f (derivative f) + f * derivative g + f * derivative g</c>, <c> : IsCoprime f (derivative f) + f * derivative g</c>, <c> : IsCoprime f (derivative f) + f * derivative g</c>] at this", "rwa [<c> : IsCoprime f (derivative f) + f * derivative g</c>, <c> : IsCoprime f (derivative f) + f * derivative g</c>, <c> : IsCoprime f (derivative f) + f * derivative g</c>, <c> : IsCoprime f (derivative f) + f * derivative g</c>] at this"], "predictions1": ["exact <c> (h : IsCoprime x y) : IsCoprime x y</c> this", "exact <c> {f g : R[X]} (h : Separable (f * g)) : IsCoprime f g</c> this", "exact <c> {f g : R[X]} (h : Separable (f * g)) : IsCoprime f (g + f * g)</c> this", "rwa [<c> : IsCoprime x y \u2194 IsCoprime y x</c>, <c> : IsCoprime x y \u2194 IsCoprime y x</c>] at this", "exact <c> {f g : R[X]} (h : Separable (f * g)) : IsCoprime f (derivative f + f * g)</c> this", "rwa [<c> : IsCoprime x y \u2194 IsCoprime y x</c>, <c> : IsCoprime x y \u2194 IsCoprime x y</c>] at this", "exact <c> {f g : R[X]} (h : Separable (f * g)) : IsCoprime f (g + f * g)</c> h", "exact <c> {f g : R[X]} (h : Separable (f * g)) :\n    IsCoprime f (derivative f + f * g)</c> this"], "predictions2": ["rwa [<c> : IsCoprime x y \u2194 IsCoprime y x</c>] at this", "rwa [<c> : IsCoprime (x + y) \u2194 IsCoprime x y</c>] at this", "rwa [<c> : IsCoprime x y \u2194 IsCoprime y x</c>, <c> : IsCoprime x y \u2194 IsCoprime y x</c>] at this", "rwa [<c> : IsCoprime (x + y) \u2194 IsCoprime x y</c>, <c> : IsCoprime x y \u2194 IsCoprime y x</c>] at this", "rwa [<c> : \u2200 a b : G, a * b = b * a</c>] at this", "rwa [<c> : IsCoprime x y \u2194 IsCoprime y x</c>, <c> : IsCoprime x y \u2194 IsCoprime x y</c>] at this", "rwa [<c> : IsCoprime (x + y) \u2194 IsCoprime x y</c>, <c> : IsCoprime x y \u2194 IsCoprime x y</c>] at this", "rwa [<c> : \u2200 a b : G, a * b = b * a</c>, <c> : \u2200 a b : G, a * b = b * a</c>] at this"]}, {"state_before": "case mpr\nC : Type u\ninst\u271d : Groupoid C\nS : Subgroupoid C\nh : objs S = univ\nc : C\n\u22a2 \ud835\udfd9 c \u2208 S.arrows c c", "expanded_tactic": "obtain \u27e8\u03b3, \u03b3S\u27e9 := (<c> {a b : \u03b1} : a = b \u2192 a \u2264 b</c> h.symm : \u22a4 \u2286 S.objs) (<c> (x : \u03b1) : x \u2208 @univ \u03b1</c> c)", "predictions0": ["obtain \u27e8c, rfl\u27e9 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "obtain \u27e8c, hc\u27e9 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "obtain \u27e8c', rfl\u27e9 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "obtain \u27e8c', hc'\u27e9 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "obtain \u27e8c, rfl\u27e9 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> h", "obtain \u27e8c, rfl\u27e9 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> c", "obtain \u27e8c, rfl\u27e9 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> (<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>)", "obtain \u27e8c', rfl\u27e9 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> h"], "predictions1": ["have : c \u2208 S.objs c := by rw [h]; exact <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "rw [\u2190 <c> (S : Subgroupoid C) (c : C) : \ud835\udfd9 c \u2208 S.arrows c</c> S c]", "rw [\u2190 <c> (S : Subgroupoid C) (c : C) : \ud835\udfd9 c \u2208 S.arrows c</c> S c, h]", "rw [\u2190 <c> (S : Subgroupoid C) (c : C) :\n    \ud835\udfd9 c \u2208 S.arrows c c \u2194 \ud835\udfd9 c \u2208 S.arrows c</c> S h]", "rw [\u2190 <c> (S : Subgroupoid C) (c : C) : \ud835\udfd9 c \u2208 S.arrows c \u2194 \ud835\udfd9 c \u2208 S.arrows c</c> S h]", "rw [\u2190 <c> (S : Subgroupoid C) (c : C) :\n    \ud835\udfd9 c \u2208 S.arrows c c \u2194 \ud835\udfd9 c \u2208 S.arrows c</c>, h]", "rw [\u2190 <c> (S : Subgroupoid C) (c : C) : \ud835\udfd9 c \u2208 S.arrows c \u2194 \ud835\udfd9 c \u2208 S.arrows c</c>, h]", "rw [\u2190 <c> (S : Subgroupoid C) (c : C) :\n    \ud835\udfd9 c \u2208 S.arrows c \u2194 \ud835\udfd9 c \u2208 S.arrows c</c> S h]"], "predictions2": ["rw [\u2190 <c> {x : B} : x \u2208 (p : Set B) \u2194 x \u2208 p</c>, \u2190 h]", "obtain rfl | hc := <c> (x y : \u03b1) : x = y \u2228 x \u2260 y</c> c 0", "obtain rfl | hc := <c> (x y : \u03b1) : x = y \u2228 x \u2260 y</c> c (S.objs c)", "obtain rfl | hc := <c> (x y : \u03b1) : x = y \u2228 x \u2260 y</c> c (<c> (x : \u03b1) : x \u2208 @univ \u03b1</c> c)", "obtain rfl | hc := <c> (x y : \u03b1) : x = y \u2228 x \u2260 y</c> c (S.inv c)", "have : c \u2208 S.arrows c := by rw [h]; exact <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "rw [\u2190 <c> {x : B} : x \u2208 (p : Set B) \u2194 x \u2208 p</c>, h]", "obtain rfl | hc := <c> (x y : \u03b1) : x = y \u2228 x \u2260 y</c> c"]}, {"state_before": "X : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns : CompositionSeries X\nh : 0 < s.length\ni : Fin (s.length - 1 + 1)\n\u22a2 \u2191i < s.length", "expanded_tactic": "conv_rhs => rw [\u2190 <c> (n : Nat) : (n + 1) - 1 = n</c> s.length, <c> {m n : Nat} (h : n \u2264 m) : succ m - n = succ (m - n)</c> h]", "predictions0": ["simpa using i.2", "exact i.2", "omega", "exact <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "simpa using i.2.<c></c> h", "simpa using i.2.<c></c>", "simpa using i.2.<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "exact <c> {\u03b1 : Sort u} {a b : \u03b1} : Eq a a</c>"], "predictions1": ["exact i.2", "simpa using i.2", "exact i.2.<c></c>", "exact <c> : \u2200 {a b c : \u03b1}, a < b \u2192 b < c \u2192 a < c</c> h i.2", "exact <c> (n : Nat) : LT.lt 0 (succ n)</c> i", "exact <c> (n : Nat) : n < succ n</c> i", "exact <c> : \u2200 {a b c : \u03b1}, a < b \u2192 b < c \u2192 a < c</c> i.2 h", "exact <c> {a b : Fin n} : a < b \u2194 a.1 < b.1</c>.1 i.2"], "predictions2": ["exact i.2.<c></c>", "exact <c> : \u2200 a : Fin n, 0 < a</c> _", "exact <c> : \u2200 {a b c : \u03b1}, a < b \u2192 b < c \u2192 a < c</c> h i.2", "exact <c> (n : Nat) : LT.lt 0 (succ n)</c> i", "exact <c> : \u2200 a : Fin n, 0 < a</c> i", "exact <c> {a b : Fin n} : a < b \u2192 a.1 < b.1</c> h", "exact <c> : \u2200 {a b : \u03b1}, a < b \u2192 a \u2264 b</c> h", "exact <c> (n : Nat) : LT.lt 0 (succ n)</c> _"]}, {"state_before": "F : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\n\u03b1 : E\nm n : \u2115\nhneq : m \u2260 n\nheq : F\u27ee\u03b1 ^ m\u27ef = F\u27ee\u03b1 ^ n\u27ef\n\u22a2 IsAlgebraic F \u03b1", "expanded_tactic": "wlog hmn : m < n", "predictions0": ["obtain \u27e8n, hn\u27e9 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "obtain \u27e8n, rfl\u27e9 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "obtain \u27e8n, hn\u27e9 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> heq", "obtain \u27e8n, rfl\u27e9 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> heq", "obtain \u27e8n, hn\u27e9 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> heq.symm", "obtain \u27e8n, hn\u27e9 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> (<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>)", "obtain \u27e8n, hn\u27e9 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> (<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> heq)", "obtain \u27e8n, hn\u27e9 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> (<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>) heq"], "predictions1": ["rcases <c> (x y : \u03b1) : x = y \u2228 x \u2260 y</c> F \u03b1 with (rfl | hneq)", "rcases <c> (x y : \u03b1) : x = y \u2228 x \u2260 y</c> F \u03b1 with rfl | h\u03b1", "rcases <c> (x y : \u03b1) : x = y \u2228 x \u2260 y</c> F \u03b1 with rfl | hn", "rcases <c> (x y : \u03b1) : x = y \u2228 x \u2260 y</c> F \u03b1 with h | h", "rcases <c> (x y : \u03b1) : x = y \u2228 x \u2260 y</c> \u03b1 m with (rfl | hneq)", "rcases <c> (x y : \u03b1) : x = y \u2228 x \u2260 y</c> \u03b1 n with (rfl | hneq)", "rcases <c> (x y : \u03b1) : x = y \u2228 x \u2260 y</c> F \u03b1 with (rfl | hneq')", "rcases <c> (x y : \u03b1) : x = y \u2228 x \u2260 y</c> F \u03b1 with rfl|hn"], "predictions2": ["rcases <c> (x y : \u03b1) : x = y \u2228 x \u2260 y</c> F \u03b1 with (rfl | hF')", "rcases <c> (x y : \u03b1) : x = y \u2228 x \u2260 y</c> F \u03b1 with rfl | h\u03b1", "rcases <c> (x y : \u03b1) : x = y \u2228 x \u2260 y</c> F \u03b1 with rfl | hn", "rcases <c> (x y : \u03b1) : x = y \u2228 x \u2260 y</c> F \u03b1 with (rfl | hneq')", "rcases <c> (x y : \u03b1) : x = y \u2228 x \u2260 y</c> F \u03b1 with rfl|hn", "rcases <c> (x y : \u03b1) : x = y \u2228 x \u2260 y</c> F \u03b1 with (rfl | hF)", "rcases <c> (x y : \u03b1) : x = y \u2228 x \u2260 y</c> F \u03b1 with (rfl | h0)", "by_cases h\u03b1 : <c> (\u03b1 : Type*) : Prop where\n  \n  exists_pair_ne : \u2203 x y : \u03b1, x \u2260 y</c> F"]}, {"state_before": "C : Type u\ninst\u271d\u2074 : Category.{v, u} C\ninst\u271d\u00b3 : HasZeroObject C\ninst\u271d\u00b2 : HasShift C \u2124\ninst\u271d\u00b9 : Preadditive C\ninst\u271d : \u2200 (n : \u2124), Functor.Additive (shiftFunctor C n)\nhC : Pretriangulated C\nT\u2081 T\u2082 : Triangle C\nhT\u2081 : T\u2081 \u2208 distinguishedTriangles\nhT\u2082 : T\u2082 \u2208 distinguishedTriangles\na : T\u2081.obj\u2081 \u27f6 T\u2082.obj\u2081\nc : T\u2081.obj\u2083 \u27f6 T\u2082.obj\u2083\ncomm : T\u2081.mor\u2083 \u226b (shiftFunctor C 1).map a = c \u226b T\u2082.mor\u2083\n\u22a2 (Triangle.invRotate T\u2081).mor\u2081 \u226b a = (shiftFunctor C (-1)).map c \u226b (Triangle.invRotate T\u2082).mor\u2081", "expanded_tactic": "dsimp", "predictions0": ["dsimp", "simpa using comm", "simp", "simp only [<a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>]", "simp only [<a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.id_comp</a>, <a>Category.comp_id</a>]", "simp only [<a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>]", "simp only [<a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.id_comp</a>, <a>Category.comp_id</a>, <a>Category.assoc</a>]", "simp only [<a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.id_comp</a>, <a>Category.comp_id</a>, <a>Category.id_comp</a>]"], "predictions1": ["dsimp", "dsimp only [<c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c>]", "dsimp only [<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>]", "simp only [\u2190 <c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> (<c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> _ _)]", "simp only [\u2190 <c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> (<c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> _ _), comm]", "simp only [\u2190 <c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> (<c> (C : Type u) [Category.{v} C] [ConcreteCategory.{w} C] [ConcreteCategory.{w} C]\n    [HasZeroMorphisms C] {X Y : C} {f : X \u27f6 Y} {Z : C} :\n    f \u226b (0 : Y \u27f6 Z) = (0 : X \u27f6 Z)</c>]", "simp only [\u2190 <c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> (<c> (C : Type u) [Category.{v} C] [ConcreteCategory.{w} C] [ConcreteCategory.{w} C]\n    [HasZeroMorphisms C] {X Y : C} {f : X \u27f6 Y} {Z : C} :\n    f \u226b (0 : Y \u27f6 Z) = (0 : X \u27f6 Z)</c>, comm]", "simp only [\u2190 <c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> (<c> (C : Type u) [Category.{v} C] [ConcreteCategory.{w} C] [ConcreteCategory.{w} C]\n    [ConcreteCategory.{w} C] [ConcreteCategory.{w} C] [ConcreteCategory.{w} C] [ConcreteCategory.{w} C]\n    [HasZeroMorphisms C] {X Y : C} {f : X \u27f6 Y} {Z : C} :\n    f \u226b (0 : Y \u27f6 Z) = (0 : X \u27f6 Z)</c>]"], "predictions2": ["dsimp [<c> : Triangle C \u2964 Triangle C</c>]", "dsimp [<c> : Triangle C \u2964 Triangle C where\n  obj T</c>]", "dsimp [<c> : Triangle C \u2964 Triangle C where\n  obj</c>]", "dsimp [<c> : Triangle C \u2964 Triangle C where\n  obj a</c>]", "dsimp [<c> : Triangle C \u2964 Triangle C where\n  obj\u2081</c>]", "dsimp [<c> : Triangle C \u2964 Triangle C where\n  obj X</c>]", "dsimp", "dsimp [<c> : Triangle C \u2964 Triangle C where\n  obj T</c>, <c> : Triangle C \u2964 Triangle C where\n  obj T</c>]"]}, {"state_before": "K : Type uK\ninst\u271d\u2074 : Field K\nV\u2081 : Type uV\u2081\nV\u2082 : Type uV\u2082\ninst\u271d\u00b3 : AddCommGroup V\u2081\ninst\u271d\u00b2 : Module K V\u2081\ninst\u271d\u00b9 : AddCommGroup V\u2082\ninst\u271d : Module K V\u2082\nW W' : Subspace K V\u2081\nF : V\u2081 \u2192\u2097[K] (V\u2081 \u29f8 W) \u00d7 V\u2081 \u29f8 W' := LinearMap.prod (mkQ W) (mkQ W')\nthis : LinearMap.ker F = W \u2293 W'\n\u03c6 : Dual K V\u2081\n\u22a2 \u03c6 \u2208 LinearMap.range (LinearMap.dualMap F) \u2192 \u03c6 \u2208 dualAnnihilator W \u2294 dualAnnihilator W'", "expanded_tactic": "rw [<c> [RingHomSurjective \u03c4\u2081\u2082] {f : F} {x} : x \u2208 range f \u2194 \u2203 y, f y = x</c>]", "predictions0": ["rw [<c> (\u03c6 : LinearMap.range \u03c6) : \u03c6 \u2208 W.dualAnnihilator</c>]", "rw [<c> (\u03c6 : LinearMap.range \u03c6) : \u03c6 \u2208 W.dualAnnihilator \u2194 \u03c6 \u2208 W</c>]", "rw [<c> (\u03c6 : LinearMap.range \u03c6) : \u03c6 \u2208 W.dualAnnihilator \u2194 \u03c6 \u2208 W.dualAnnihilator</c>]", "rw [<c> (\u03c6 : Submodule K V\u2081) : \u03c6 \u2208 W.dualAnnihilator \u2194 \u03c6 \u2208 W.dualAnnihilator</c>]", "rw [<c> (\u03c6 : LinearMap.range \u03c6) : \u03c6 \u2208 W.dualAnnihilator \u2194 \u03c6 \u2208 W'.dualAnnihilator</c>]", "rw [<c> (\u03c6 : Submodule K V\u2081) : \u03c6 \u2208 W.dualAnnihilator \u2194 \u03c6 \u2208 W'.dualAnnihilator</c>]", "rw [<c> (\u03c6 : LinearMap.range \u03c6) :\n    \u03c6 \u2208 W.dualAnnihilator \u2194 \u03c6 \u2208 W.dualAnnihilator</c>]", "rw [<c> (\u03c6 : LinearMap.range \u03c6) :\n    \u03c6 \u2208 W.dualAnnihilator \u2194 \u03c6 \u2208 W'.dualAnnihilator</c>]"], "predictions1": ["rw [<c> {x : B} : x \u2208 (p : Set B) \u2194 x \u2208 p</c>]", "rw [<c> : x \u2208 p \u2294 p' \u2194 \u2203 y \u2208 p, \u2203 z \u2208 p', y + z = x</c>]", "simp only [<c> {x : B} : x \u2208 (p : Set B) \u2194 x \u2208 p</c>]", "rw [<c> {x : B} : x \u2208 (p : Set B) \u2194 x \u2208 p</c>, <c> {x : B} : x \u2208 (p : Set B) \u2194 x \u2208 p</c>]", "simp only [<c> {x : B} : x \u2208 (p : Set B) \u2194 x \u2208 p</c>, <c> {x : B} : x \u2208 (p : Set B) \u2194 x \u2208 p</c>]", "simp only [<c> : x \u2208 p \u2294 p' \u2194 \u2203 y \u2208 p, \u2203 z \u2208 p', y + z = x</c>]", "rw [<c> {x : B} : x \u2208 (p : Set B) \u2194 x \u2208 p</c>, <c> : x \u2208 p \u2294 p' \u2194 \u2203 y \u2208 p, \u2203 z \u2208 p', y + z = x</c>]", "simp only [<c> {x : B} : x \u2208 (p : Set B) \u2194 x \u2208 p</c>, <c> : x \u2208 p \u2294 p' \u2194 \u2203 y \u2208 p, \u2203 z \u2208 p', y + z = x</c>]"], "predictions2": ["rw [<c> {x : B} : x \u2208 (p : Set B) \u2194 x \u2208 p</c>]", "rw [<c> : x \u2208 range f \u2194 \u2203 y, f y = x</c>]", "simp only [<c> {x : B} : x \u2208 (p : Set B) \u2194 x \u2208 p</c>]", "simp only [<c> : x \u2208 range f \u2194 \u2203 y, f y = x</c>]", "simp only [<c> {x : B} : x \u2208 (p : Set B) \u2194 x \u2208 p</c>, <c> {x : B} : x \u2208 (p : Set B) \u2194 x \u2208 p</c>]", "simp only [<c> {x : B} : x \u2208 (p : Set B) \u2194 x \u2208 p</c>, <c> : x \u2208 (p : Set B) \u2194 x \u2208 p</c>]", "simp only [<c> {x : B} : x \u2208 (p : Set B) \u2194 x \u2208 p</c>, <c> {x : M} : x \u2208 (p : Set B) \u2194 x \u2208 p</c>]", "simp only [<c> {x : B} : x \u2208 (p : Set B) \u2194 x \u2208 p</c>, <c> : (\u2203 _h : a, b) \u2194 a \u2227 b</c>]"]}, {"state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : IsWeakLowerModularLattice \u03b1\na b : \u03b1\n\u22a2 a \u22d6 a \u2294 b \u2192 b \u22d6 a \u2294 b \u2192 a \u2293 b \u22d6 b", "expanded_tactic": "rw [<c> (a b : \u03b1) : a \u2294 b = b \u2294 a</c>, <c> (a b : \u03b1) : a \u2293 b = b \u2293 a</c>]", "predictions0": ["rw [<c> (a b : \u03b1) : a \u22d6 b \u2294 b \u2294 a \u2294 b</c>]", "exact <c> {a b : \u03b1} : a \u22d6 b \u2294 b \u2192 a \u22d6 b</c>", "rw [<c> (a b : \u03b1) : a \u22d6 b \u2294 b \u2194 a \u22d6 b</c>]", "exact <c> {a b : \u03b1} : a \u22d6 b \u2294 b \u2192 a \u22d6 b \u2294 b</c>", "exact <c> {a b : \u03b1} : a \u22d6 b \u2294 b \u2192 a \u22d6 b \u2294 a \u2294 b</c>", "rw [<c> (a b : \u03b1) : a \u22d6 b \u2294 b \u2294 a \u2294 b</c>, <c> (a b : \u03b1) : a \u22d6 b \u2294 b \u2294 a \u2294 b</c>]", "simpa only [<c> (a b : \u03b1) : a \u22d6 b \u2294 b \u2294 a \u2294 b</c>] using <c> (a b : \u03b1) : a \u22d6 b \u2294 b \u2294 a \u2294 b</c>", "simpa only [<c> (a b : \u03b1) : a \u22d6 b \u2294 b \u2194 a \u22d6 b</c>] using <c> (a b : \u03b1) : a \u22d6 b \u2294 b \u2294 a \u2294 b</c>"], "predictions1": ["rw [<c> : a \u22d6 b \u2294 b \u2194 a \u22d6 b</c>]", "exact <c> {a b : \u03b1} : a \u22d6 b \u2192 a \u22d6 b \u2192 a \u22d6 b</c>", "exact <c> (ha : a \u22d6 b) (hb : b \u22d6 a \u2294 b) : a \u2293 b \u22d6 b</c>", "exact <c> {a b : \u03b1} : a \u22d6 b \u2192 b \u22d6 a \u2294 b \u2192 a \u22d6 b</c>", "exact <c> [IsWeakLowerModularLattice \u03b1] {a b : \u03b1} :\n    a \u22d6 b \u2192 a \u22d6 b \u2192 a \u22d6 b</c>", "exact <c> [IsWeakLowerModularLattice \u03b1] (a b : \u03b1) :\n    a \u22d6 b \u2294 b \u2192 a \u22d6 b</c>", "exact <c> [IsWeakLowerModularLattice \u03b1] {a b : \u03b1} :\n    a \u22d6 a \u2294 b \u2192 a \u22d6 b \u2192 a \u22d6 b</c>", "exact <c> [IsWeakLowerModularLattice \u03b1] {a b : \u03b1} :\n    a \u22d6 b \u2192 a \u22d6 b \u2192 a \u22d6 b \u2192 a \u22d6 b</c>"], "predictions2": ["exact <c> (h : a \u22d6 b) : a \u22d6 b</c>", "exact <c> : a \u22d6 b \u2293 a \u2194 a \u22d6 b</c>", "exact <c> (h : a \u22d6 b) : a \u22d6 b \u2293 a</c>", "exact <c> (ha : a \u22d6 b) (hb : b \u22d6 a) : a \u22d6 b</c>", "exact <c> : a \u22d6 b \u2293 c \u2194 a \u22d6 b \u2293 c</c>", "exact <c> (hab : a \u22d6 b) (hba : b \u22d6 a) : a \u22d6 b</c>", "exact <c> (h\u2081 : a \u22d6 b) (h\u2082 : b \u22d6 c) : a \u22d6 b \u2293 c</c>", "exact <c> (h\u2081 : a \u22d6 b) (h\u2082 : b \u22d6 c) : a \u22d6 b</c>"]}, {"state_before": "case e_s\nK : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : NoZeroDivisors K\nG : Subgroup K\u02e3\ninst\u271d : Fintype \u21a5G\nk : \u2115\nk_pos : k \u2260 0\nk_lt_card_G : k < Fintype.card \u21a5G\na\u271d : Nontrivial K\nthis : IsDomain K\na : \u21a5G\nha : a ^ k \u2260 1\nas_comp : (fun x => (\u2191\u2191x * \u2191\u2191a) ^ k) = (fun x => \u2191\u2191x ^ k) \u2218 fun x => x * a\n\u22a2 Multiset.map (fun x => x * a) univ.val = univ.val", "expanded_tactic": "exact <c> (e : \u03b1 \u2243 \u03b2) :\n    map e univ.val = univ.val</c> (<c> (a : G) : Perm G</c> a)", "predictions0": ["exact <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "refine' <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun x hx => _", "refine' <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun x _ => _", "refine' <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> fun x => _", "exact <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> (<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>)", "rw [<c> {f : \u03b1 \u2192 \u03b2} {s : Multiset \u03b1} : map f s = s</c>]", "rw [<c> {f : \u03b1 \u2192 \u03b2} {s : Multiset \u03b1} : map f s = univ</c>]", "rw [<c> {f : \u03b1 \u2192 \u03b2} {s : Multiset \u03b1} :\n    Multiset.map f s = univ.val</c>]"], "predictions1": ["exact <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "rw [<c> {f : \u03b1 \u2192 \u03b2} {s : Multiset \u03b1} : map f s = s.map f</c>]", "exact <c> {f : \u03b1 \u2192 \u03b2} {s : Multiset \u03b1} : map f s = s.map f</c>", "rw [<c> {f : \u03b1 \u2192 \u03b2} {s : Multiset \u03b1} : map f s = s \u2194 s = univ</c>]", "rw [<c> {f : \u03b1 \u2192 \u03b2} {s : Multiset \u03b1} : map f s = s.1.map f</c>]", "rw [\u2190 <c> (f : \u03b1 \u21aa \u03b2) (s : Multiset \u03b1) : map f (s.map f) = s.map f</c>]", "exact <c> {\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {f g : (x : \u03b1) \u2192 \u03b2 x}\n    (h : \u2200 x, f x = g x) : f = g</c> fun x => <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "exact <c> {\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {f g : (x : \u03b1) \u2192 \u03b2 x}\n    (h : \u2200 x, f x = g x) : map f univ = g</c> fun x => <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>"], "predictions2": ["exact <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "rw [<c> {f : \u03b1 \u2192 \u03b2} {s : Multiset \u03b1} : map f s = \u2205 \u2194 s = \u2205</c>]", "rw [<c> {f : \u03b1 \u2192 \u03b2} {s : Multiset \u03b1} : map f s = map f s</c>]", "rw [<c> {f : \u03b1 \u2192 \u03b2} {s : Multiset \u03b1} : map f s = \u2205 \u2194 s = 0</c>]", "exact <c> {s : Multiset \u03b1} {f : \u03b1 \u2192 Multiset \u03b2} :\n    (s.map f).map f = s.map f</c>", "exact <c> {\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {f g : (x : \u03b1) \u2192 \u03b2 x}\n    (h : \u2200 x, f x = g x) : f = g</c> fun _ => <c> {\u03b1 : Sort u} {a : \u03b1} : Eq", "exact <c> {\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {f g : (x : \u03b1) \u2192 \u03b2 x}\n    (h : \u2200 x, f x = g x) : f = g</c> fun _ \u21a6 <c> {\u03b1 : Sort u} {a : \u03b1} : Eq", "exact <c> {f : \u03b1 \u2192 \u03b2} {s : Multiset \u03b1} : map f s = \u2205 \u2194 s = \u2205</c>"]}, {"state_before": "F : Type u_1\ninst\u271d\u00b2 : Field F\nE : Type u_2\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\n\u03b1\u271d \u03b1 : E\nq : F[X]\nq_irred : Irreducible q\nq_aeval : (aeval \u03b1) q = 0\nh\u03b1 : IsSolvableByRad F \u03b1\n\u22a2 IsSolvable (Gal (minpoly F { val := \u03b1, property := h\u03b1 }))", "expanded_tactic": "exact <c> (\u03b1 : solvableByRad F E) : IsSolvable (minpoly F \u03b1).Gal</c> \u27e8\u03b1, h\u03b1\u27e9", "predictions0": ["exact <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "exact <c> : IsSolvableByRad F \u03b1</c> F \u03b1", "exact <c> : IsSolvableByRad F \u03b1</c>", "exact <c> : IsSolvableByRad F \u03b1</c> _", "exact <c> : IsSolvable (minpoly F \u27e8\u03b1, h\u03b1\u27e9)</c> F \u03b1", "exact <c> : IsSolvable (minpoly F \u27e8\u03b1, h\u03b1\u27e9)</c> F _", "exact <c> : IsSolvable (minpoly F \u27e8\u03b1, h\u03b1\u27e9)</c> F \u27e8\u03b1, h\u03b1\u27e9", "exact <c> : IsSolvable (minpoly F \u27e8\u03b1, h\u03b1\u27e9)</c>"], "predictions1": ["exact <c> [IsSolvableByRad F \u03b1] : IsSolvableByRad F \u03b1</c> F \u03b1", "exact <c> [IsSolvableByRad F E] : IsSolvableByRad F E</c> F \u03b1", "exact <c> [IsSolvableByRad F \u03b1] (h\u03b1 : IsSolvableByRad F \u03b1) :\n    IsSolvableByRad F \u03b1</c> F \u03b1", "exact <c> [IsSolvableByRad F \u03b1] (h\u03b1 : IsSolvableByRad F \u03b1) :\n    IsSolvable (minpoly F \u03b1)</c> q_irred q_aeval", "exact <c> [IsSolvableByRad F E] (h\u03b1 : IsSolvableByRad F \u03b1) :\n    IsSolvable (minpoly F \u03b1)</c> q_irred q_aeval", "exact <c> [IsSolvableByRad F \u03b1] (h\u03b1 : IsSolvableByRad F \u03b1) :\n    IsSolvable (minpoly F \u03b1)</c> F \u03b1", "exact <c> [IsSolvableByRad F \u03b1] (h\u03b1 : IsSolvableByRad F \u03b1) : IsSolvable (minpoly F \u03b1)</c> q_irred q_aeval", "exact <c> [IsSolvableByRad F \u03b1] (h\u03b1 : IsSolvableByRad F \u03b1) :\n    IsSolvable (minpoly F \u27e8\u03b1, h\u03b1\u27e9)</c> q_irred q_aeval"], "predictions2": ["exact <c> {\u03b1 : Sort u} [i : \u03b1] : \u03b1</c>", "exact <c> : IsSolvableByRad F \u03b1</c> F \u03b1", "exact <c> {\u03b1 : Sort u} (a : \u03b1) : \u03b1</c>", "exact <c> : IsSolvableByRad F \u03b1</c>", "exact <c> (\u03b1 : Type*) [Field F] [IsSolvable F \u03b1] :\n    IsSolvable (minpoly F \u03b1)</c> F \u03b1", "exact <c> (\u03b1 : Type*) [Field F] [IsSolvable F \u03b1] :\n    IsSolvable F \u03b1</c> F \u03b1", "exact <c> (\u03b1 : Type*) [Field F] [IsSolvable F \u03b1] :\n    IsSolvable F (minpoly F \u03b1)</c> F \u03b1", "exact <c> (\u03b1 : Type*) [Field F] [IsSolvableByRad F \u03b1] :\n    IsSolvable F \u03b1</c> F \u03b1"]}, {"state_before": "case h.right.x.right.e_a\nC : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nA : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} A\nA' : Type u\u2082\ninst\u271d\u00b9 : Category.{max v\u2081 u\u2081, u\u2082} A'\nB : Type u\u2083\ninst\u271d : Category.{v\u2083, u\u2083} B\nJ : GrothendieckTopology C\nU : C\nR : Presieve U\nP : C\u1d52\u1d56 \u2964 A\nP' : C\u1d52\u1d56 \u2964 A'\nh : \u2200 (X : C) (S : GrothendieckTopology.Cover J X), Nonempty (IsLimit (GrothendieckTopology.Cover.multifork S P))\nE : A\nX : C\nS : Sieve X\nhS : S \u2208 J.sieves X\nx : Presieve.FamilyOfElements (P \u22d9 coyoneda.obj (op E)) S.arrows\nhx : Presieve.FamilyOfElements.Compatible x\nT : GrothendieckTopology.Cover J X := { val := S, property := hS }\nhh : IsLimit (GrothendieckTopology.Cover.multifork T P)\nK : Multifork (GrothendieckTopology.Cover.index T P) :=\n  Multifork.of\u03b9 (GrothendieckTopology.Cover.index T P) E (fun I => x I.f \u22ef) \u22ef\ne : E \u27f6 P.obj (op X)\nhe : Presieve.FamilyOfElements.IsAmalgamation x e\nb : (GrothendieckTopology.Cover.index T P).R\n\u22a2 e \u226b\n      (GrothendieckTopology.Cover.multifork T P).\u03c0.app\n        (WalkingMulticospan.left ((GrothendieckTopology.Cover.index T P).fstTo b)) =\n    K.\u03c0.app (WalkingMulticospan.left ((GrothendieckTopology.Cover.index T P).fstTo b))", "expanded_tactic": "apply he", "predictions0": ["apply he", "rw [\u2190 <a>Category.assoc</a>]", "rw [\u2190 <a>Category.assoc</a>, K.w]", "rw [\u2190 <a>CategoryTheory.Category.assoc</a>]", "simp only [<a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>]", "simp only [<c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>]", "rw [\u2190 <c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>]", "simp only [<c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} {g : Y \u27f6 Z} : g \u226b f = h \u226b f \u2194 g = h</c>]"], "predictions1": ["apply he", "rw [K.w]", "exact (he _ _).<a>symm</a>", "apply (he _ _).<a>app</a>", "rw [\u2190 K.w (<c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).op = g.op \u226b f.op</c> _)]", "apply (<c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).op = g.op \u226b f.op</c> _).<a>symm</a>", "rw [\u2190 K.w (<c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} : (f \u226b g).op = g.op \u226b f.op</c> _)]", "rw [\u2190 K.w (<c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).op = g.op \u226b f.op</c> b)]"], "predictions2": ["apply he", "exact (he _ (T.base_open.isOpen_range _)).<a>symm</a>", "exact (he _ (T.index_eq_right _ _)).<a>symm</a>", "exact (he _ (T.multifork_left _)).<a>symm</a>", "exact (he _ (T.multifork_\u03c0 P)).<c> {V} [Quiver V] {X Y : V} (f : X \u27f6 Y) : </c>", "exact (he _ (T.base_open.isOpen_range _)).<c> {V} [Quiver V] {X Y : V} (f : X \u27f6 Y) : </c>", "exact he _ (<c> {X Y : C} (f : X \u27f6 Y) : X \u27f6 Y</c> _)", "exact he _ (<c> {X Y : C} (f : X \u27f6 Y) : X \u27f6 Y</c> b)"]}, {"state_before": "X : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\nx y : X\nhxz : IsMaximal x (y \u2294 x)\nhyz : IsMaximal y (y \u2294 x)\n\u22a2 IsMaximal (y \u2293 x) y", "expanded_tactic": "exact <a>isMaximal_inf_left_of_isMaximal_sup</a> hyz hxz", "predictions0": ["rw [<c> (a b : \u03b1) : a \u2293 b = b \u2294 a</c>]", "rw [<c> : JordanHolderLattice X \u2192 JordanHolderLattice X</c>] at *", "exact <c> (hxz : IsMaximal x (y \u2294 x)) (hyz : IsMaximal y (y \u2294 x)) hxz hyz", "rw [<c> : JordanHolderLattice X \u2192 JordanHolderLattice X \u2192 JordanHolderLattice X</c>] at *", "exact <c> (hxz : IsMaximal x (y \u2294 x)) (hyz : IsMaximal y (y \u2294 x))</c> hxz hyz", "exact <c> (hxz : IsMaximal x (y \u2294 x)) (hyz : IsMaximal y (y \u2294 x))</c> hxz hyz hxz", "rw [<c> : JordanHolderLattice X \u2192 JordanHolderLattice X \u2192 JordanHolderLattice X</c>] at hxz hyz", "exact <c> (hxz : IsMaximal x (y \u2294 x)) (hyz : IsMaximal y (y \u2294 x)) (hxz : IsMaximal y (y \u2294 x)) hyz hxz"], "predictions1": ["rw [<c> (a b : \u03b1) : a \u2293 b = b \u2293 a</c>]", "rw [<c> (a b : \u03b1) : a \u2293 b = b \u2294 a</c>]", "rw [<c> : IsMaximal x (y \u2294 x) \u2194 IsMaximal y x</c>] at *", "rw [<c> : IsMaximal x (y \u2294 x) \u2194 IsMaximal y (y \u2294 x)</c>] at *", "rw [<c> : IsMaximal x (y \u2294 x) \u2194 IsMaximal y x</c>] at hxz hyz", "rw [<c> (a b : \u03b1) : a \u2294 b = b \u2294 a</c>] at *", "rw [<c> : IsMaximal x (y \u2294 x) \u2194 IsMaximal y (y \u2294 x)</c>] at hxz hyz", "rw [<c> : IsMaximal x (y \u2294 x) \u2194 IsMaximal y (x \u2294 y)</c>] at *"], "predictions2": ["exact <c> (hxz : IsMaximal x (y \u2294 x)) (hyz : y \u2264 x) : IsMaximal (y \u2294 x) y</c> hxz hyz", "exact <c> {x y : X} (hxy : IsMaximal x y) : IsMaximal (y \u2294 x) y</c> hxz hyz", "exact <c> (hxz : IsMaximal x (y \u2294 x)) (hyz : IsMaximal y (y \u2294 x)) :\n    IsMaximal (y \u2294 x) y</c> hxz hyz", "exact <c> (hxz : IsMaximal x (y \u2294 x)) (hyz : y \u2264 x) :\n    IsMaximal (y \u2294 x) y</c> hxz hyz", "exact <c> (hxz : IsMaximal x (y \u2294 x)) (hyz : IsMaximal y (y \u2294 x)) : IsMaximal (y \u2294 x)</c> hxz hyz", "exact <c> (hxz : IsMaximal x (y \u2294 x)) (hyz : y \u2264 x) : IsMaximal (y \u2294 x) x</c> hxz hyz", "exact <c> (hxz : IsMaximal x (y \u2294 x)) (hyz : IsMaximal y (y \u2294 x)) : IsMaximal (y \u2294 x) y</c> hxz hyz", "exact <c> (hxz : IsMaximal x (y \u2294 x)) (hyz : IsMaximal y (x \u2294 y)) :\n    IsMaximal (y \u2294 x) y</c> hxz hyz"]}, {"state_before": "C : Type u\nA : Type u_1\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : AddCommMonoid A\ninst\u271d : HasShift C A\nX\u271d Y : C\nf : X\u271d \u27f6 Y\nm\u2081 m\u2082 m\u2083 : A\nX : C\n\u22a2 ((shiftFunctorAdd' C m\u2081 (m\u2082 + m\u2083) (m\u2081 + (m\u2082 + m\u2083)) \u22ef).symm \u226a\u226b\n              shiftFunctorAdd' C (m\u2082 + m\u2083) m\u2081 (m\u2081 + (m\u2082 + m\u2083)) \u22ef).hom.app\n        X \u226b\n      (shiftFunctor C m\u2081).map ((shiftFunctorAdd' C m\u2082 m\u2083 (m\u2082 + m\u2083) \u22ef).hom.app X) \u226b\n        ((shiftFunctorAdd' C m\u2081 m\u2083 (m\u2081 + m\u2083) \u22ef).symm \u226a\u226b shiftFunctorAdd' C m\u2083 m\u2081 (m\u2081 + m\u2083) \u22ef).inv.app\n            ((shiftFunctor C m\u2082).obj X) \u226b\n          (shiftFunctor C m\u2083).map\n            (((shiftFunctorAdd' C m\u2081 m\u2082 (m\u2081 + m\u2082) \u22ef).symm \u226a\u226b shiftFunctorAdd' C m\u2082 m\u2081 (m\u2081 + m\u2082) \u22ef).inv.app X) =\n    (shiftFunctorAdd' C m\u2082 m\u2083 (m\u2082 + m\u2083) \u22ef).hom.app ((shiftFunctor C m\u2081).obj X)", "expanded_tactic": "dsimp", "predictions0": ["dsimp", "rfl", "simp only [<a>shiftFunctorAdd'_eq_shiftFunctorAdd</a>, <a>shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shift", "simp only [<a>shiftFunctorAdd'_eq_shiftFunctorAdd'_assoc</a>, <a>shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_e", "simp only [<a>shiftFunctorAdd'_eq_shiftFunctorAdd</a>, <a>shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq</a>, <a>shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_", "simp only [<a>shiftFunctorAdd'_eq_shiftFunctorAdd</a>, <a>shiftFunctorAdd'_eq_shiftFunctorAdd'_obj</a>, <a>shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'", "simp only [<a>shiftFunctorAdd'_eq_shiftFunctorAdd</a>, <a>shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq</a>, ", "simp only [<a>shiftFunctorAdd'_eq_shiftFunctorAdd'_obj</a>, <a>shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_shiftFunctorAdd'_eq_"], "predictions1": ["simp only [<a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    ", "simp only [<a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso", "simp only [<a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso", "simp only [<a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.hom_inv_id_app</a>,\n    <", "simp only [<a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.hom_inv_id_app</a>,\n    <", "simp only [<a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>,\n    <a>Iso", "simp only [<a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>,\n    <a>Iso", "simp only [<a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app_assoc</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.hom_inv_id_app</a>,\n    <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>, <a>Iso.trans_inv</a>,\n    <"], "predictions2": ["simp only [<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>]", "simp only [<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>, <a>Iso.hom_inv_id_app</a>]", "simp only [<c> (f : X \u27f6 Y) [I : IsIso f] : f \u226b inv f = \ud835\udfd9 X</c>, <a>Iso.hom_inv_id_app</a>, <a>Iso.hom_inv_id_app</a>]", "simp only [<c> (f : X \u27f6 Y) [I : IsIso f] : f \u226b inv f = \ud835\udfd9 X</c>, <a>Iso.hom_inv_id_app</a>, <a>Iso.hom_inv_id_app_assoc</a>]", "simp only [<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>, <a>Iso.trans_inv</a>, <a>Iso.hom_inv_id_app</a>]", "simp only [<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>, <a>Iso.hom_inv_id_app</a>, <a>Iso.hom_inv_id_app</a>]", "simpa only [<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>] using <c> (m\u2081 m\u2082 m\u2083 : A) :\n    shiftFunctorAdd' C", "simpa only [<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>] using <c> (m\u2081 m\u2082 m\u2083 : A) :\n    (shiftFunctorAdd' C m\u2081 m\u2082 (m\u2081 + m\u2082) "]}, {"state_before": "case inl_inl.inl.inl\nS X\u2081 X\u2082 : Type u\nf : S \u27f6 X\u2081\ng : S \u27f6 X\u2082\ninst\u271d : Mono f\nx\u2080\u271d y\u2080\u271d : S\nh : g x\u2080\u271d = g y\u2080\u271d\n\u22a2 Rel' f g (Sum.inl (f x\u2080\u271d)) (Sum.inl (f y\u2080\u271d))", "expanded_tactic": "exact <a>Rel'.inl_inl</a> _ _ h", "predictions0": ["exact <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "rw [h]", "exact <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> h", "exact <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> (<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> h)", "exact <c> (f : S \u27f6 X) (g : S \u27f6 X) : Rel' f g (Sum.inl f) (Sum.inl g)</c> _ _ h", "exact <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> (<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>)", "exact <c> (f : S \u27f6 X) (g : S \u27f6 X) : Rel' f g (Sum.inl g) (Sum.inl g)</c> _ _ h", "exact <c> (f : S \u27f6 X\u2081) (g : S \u27f6 X\u2082) : Rel' f g (Sum.inl f) (Sum.inl g)</c> _ _ h"], "predictions1": ["exact <c>' f g (Sum.inl x) (Sum.inl x) (Sum.inl x)</c> _ _ h", "exact <c>' f g (Sum.inl (f x)) (Sum.inl (f y)) (Sum.inl (f y))</c> _ _ h", "exact <c>' f g (Sum.inl x) (Sum.inl x) (Sum.inl x) : Rel' f g (Sum.inl x) (Sum.inl x)</c> _ _ h", "exact <c>' f g (Sum.inl (f x)) (Sum.inl (f y)) : Rel' f g (Sum.inl (f y))</c> _ _ h", "exact <c>' f g (Sum.inl x) (Sum.inl x) (Sum.inl x) : Rel' f g (Sum.inl x) (Sum.inr x)</c> _ _ h", "exact <c>' f g (Sum.inl x) (Sum.inl x) (Sum.inr y) : Rel' f g (Sum.inl x) (Sum.inr y)</c> _ _ h", "exact <c>' f g (Sum.inl (f x)) (Sum.inl (f y)) : Rel' f g (Sum.inl (f y)) (Sum.inl (f y))</c> _ _ h", "exact <c>' f g (Sum.inl (f x)) (Sum.inl (f y)) (Sum.inl (f y)) : Rel' f g (Sum.inl (f y))</c> _ _ h"], "predictions2": ["exact <c>' {f g : Sum X Y} (h : f = g) (x : X) : Rel' f g (inl x)</c> h", "exact <c>' {f g : Sum X Y} (h : f = g) (x : X) : Rel' f g (inl x)</c> _ _ h", "exact <c>' {f g : Sum X Y} (h : f = g) (x : X) : Rel' f g (Sum.inl x) (Sum.inr x)</c> h", "exact <c> [Mono f] (f : S \u27f6 X) [Mono f] (x : S) : Rel' f g (Sum.inl x) (Sum.inr x)</c> f g h", "exact <c> [Mono f] (f : S \u27f6 X) [Mono f] (x : S) : Rel' f g (Sum.inl x) (Sum.inr x)</c> _ _ h", "exact <c>' [Mono f] (f : S \u27f6 X) [Mono f] (x : S) : Rel' f g (Sum.inl x) (Sum.inr x)</c> f g h", "exact <c> [Mono f] (f : S \u27f6 X) [Mono f] (x : S) : Rel' f g (Sum.inl x) (Sum.inl x)</c> _ _ h", "exact <c>' [Mono f] (f : S \u27f6 X) [Mono f] (x : S) : Rel' f g (Sum.inl x) (Sum.inr x)</c> _ _ h"]}, {"state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ns t : Set \u03b1\na b : \u03b1\ninst\u271d : Nonempty \u03b1\n\u22a2 BddBelow \u2205", "expanded_tactic": "simp only [<c> (s : Set \u03b1)</c>, <c> : lowerBounds (\u2205 : Set \u03b1) = univ</c>, <a>univ_nonempty</a>]", "predictions0": ["simp [<c> : BddBelow (\u2205 : Set \u03b1)</c>]", "simp [<c> : BddBelow \u03b1</c>]", "simp [<c> [Nonempty \u03b1] : BddBelow \u03b1</c>]", "simp only [<c> : BddBelow (\u2205 : Set \u03b1)</c>]", "simp [<c> [Nonempty \u03b1] : BddBelow (\u2205 : Set \u03b1)</c>]", "simp only [<c> : BddBelow (\u2205 : Set \u03b1)</c>, <c> : BddBelow (\u2205 : Set \u03b1)</c>]", "simp only [<c> [Nonempty \u03b1] : BddBelow \u03b1</c>]", "simp only [<c> [Nonempty \u03b1] : BddBelow (\u2205 : Set \u03b1)</c>]"], "predictions1": ["simp only [<c> : BddBelow (\u2205 : Set \u03b1)</c>, <c> : BddBelow (\u2205 : Set \u03b1)</c>]", "simp only [<c> : BddBelow (\u2205 : Set \u03b1) \u2194 BddBelow (\u2205 : Set \u03b1)</c>]", "simp only [<c> : BddBelow (\u2205 : Set \u03b1)</c>, <c> : BddBelow (\u2205 : Set \u03b1) \u2194 BddBelow (\u2205 : Set \u03b1)</c>]", "simp only [<c> : BddBelow (\u2205 : Set \u03b1) \u2205</c>, <c> : BddBelow (\u2205 : Set \u03b1)</c>]", "simp only [<c> : BddBelow (\u2205 : Set \u03b1) \u2194 BddBelow (\u2205 : Set \u03b1)</c>, <c> : BddBelow (\u2205 : Set \u03b1)</c>]", "simp only [<c> [Nonempty \u03b1] : BddBelow (\u2205 : Set \u03b1)</c>, <c> : BddBelow (\u2205 : Set \u03b1)</c>]", "simp only [<c> : BddBelow (\u2205 : Set \u03b1)</c>, <c> : BddBelow (\u2205 : Set \u03b1)</c>, <c> : BddBelow (\u2205 : Set \u03b1)</c>]", "simp only [<c> : BddBelow (\u2205 : Set \u03b1)</c>, <c> : BddBelow (\u2205 : Set \u03b1)</c>, <c> : (\u2205 : Set \u03b1).Nonempty</c>]"], "predictions2": ["simp only [<c> (s : Set \u03b1)</c>, <c> : (\u2205 : Set \u03b1)\u1d9c = univ</c>, <c> : univ \u2208 f</c>]", "simp only [<c> (s : Set \u03b1) [Nonempty \u03b1] : BddBelow (\u2205 : Set \u03b1)</c>, <c> : (\u2205 : Set \u03b1)\u1d9c = univ</c>]", "simp only [<c> (s : Set \u03b1) [Nonempty \u03b1] : BddBelow (\u2205 : Set \u03b1) \u2194 BddAbove s</c>, <c> : (\u2205 : Set \u03b1)\u1d9c = univ</c>]", "simp only [<c> (s : Set \u03b1) [Nonempty \u03b1] : BddBelow (\u2205 : Set \u03b1) \u2194 BddBelow s</c>, <c> : (\u2205 : Set \u03b1)\u1d9c = univ</c>]", "simp only [<c> (s : Set \u03b1)</c>, <c> : lowerBounds (\u2205 : Set \u03b1) = \u2205</c>, <c> : (\u2205 : Set \u03b1)\u1d9c = univ</c>]", "simp only [<c> (s : Set \u03b1) [Nonempty \u03b1] : BddBelow (\u2205 : Set \u03b1)</c>, <c> : (\u2205 : Set \u03b1)\u1d9c = univ</c>, <c> : univ \u2208 f</c>]", "simp only [<c> (s : Set \u03b1) [Nonempty \u03b1] : BddBelow (\u2205 : Set \u03b1) \u2194 Nonempty \u03b1</c>, <c> : (\u2205 : Set \u03b1)\u1d9c = univ</c>]", "simp only [<c> (s : Set \u03b1) [Nonempty \u03b1] : BddBelow (\u2205 : Set \u03b1)</c>, <c> : (\u2205 : Set \u03b1)\u1d9c = univ</c>, <c> : (\u2205 : Set \u03b1)\u1d9c = univ</c>]"]}, {"state_before": "case refine'_2\nC : Type u\ninst\u271d\u2074 : Category.{v, u} C\ninst\u271d\u00b3 : HasZeroObject C\ninst\u271d\u00b2 : HasShift C \u2124\ninst\u271d\u00b9 : Preadditive C\ninst\u271d : \u2200 (n : \u2124), Functor.Additive (shiftFunctor C n)\nhC : Pretriangulated C\nT T' : Triangle C\n\u03c6 : T \u27f6 T'\nhT : T \u2208 distinguishedTriangles\nhT' : T' \u2208 distinguishedTriangles\nh\u2081 : IsIso \u03c6.hom\u2081\nh\u2083 : IsIso \u03c6.hom\u2083\nthis : Mono \u03c6.hom\u2082\nA : C\ny\u2082 : A \u27f6 T'.obj\u2082\n\u22a2 \u2203 a, (fun x => x \u226b \u03c6.hom\u2082) a = y\u2082", "expanded_tactic": "obtain \u27e8x\u2083, hx\u2083\u27e9 : \u2203 (x\u2083 : A \u27f6 T.obj\u2083), x\u2083 \u226b \u03c6.hom\u2083 = y\u2082 \u226b T'.mor\u2082 :=\n      \u27e8y\u2082 \u226b T'.mor\u2082 \u226b <a>inv</a> \u03c6.hom\u2083, by simp\u27e9", "predictions0": ["obtain \u27e8y\u2081, hy\u2082\u27e9 := <c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> \u03c6.hom\u2082 y\u2082", "obtain \u27e8y\u2081, hy\u2082\u27e9 := <c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> \u03c6.hom\u2083 y\u2082", "obtain \u27e8y\u2081, hy\u2082\u27e9 := <c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} {g : Y \u27f6 Z} : g \u226b f = h \u226b f \u2194 g = h</c>.1 hT'", "obtain \u27e8y\u2081, hy\u2082\u27e9 := <c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> (<c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : g \u226b f = h \u226b f \u2194 g = h</c> \u03c6.hom\u2082)", "obtain \u27e8y\u2081, hy\u2082\u27e9 := <c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} {g : Y \u27f6 Z} : g \u226b f = h \u226b f \u2194 g = h</c> (<c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : f \u226b g = h \u226b f \u2194 g = h</c> \u03c6.hom\u2082)", "obtain \u27e8y\u2081, hy\u2082\u27e9 := <c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> (<c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {g : Y \u27f6 Z} : g \u226b f = h \u226b f \u2194 g = h</c> \u03c6.hom\u2082)", "obtain \u27e8y\u2081, hy\u2082\u27e9 := <c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> (<c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} {g : Y \u27f6 Z} : g \u226b f = h \u226b f \u2194 g = h</c> \u03c6.hom\u2082)", "obtain \u27e8y\u2081, hy\u2082\u27e9 := <c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> (<c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {g : Y \u27f6 Z} : g \u226b f = h \u226b f \u2194 g = h</c> \u03c6.hom\u2082 y\u2082)"], "predictions1": ["obtain \u27e8y\u2081, hy\u2082\u27e9 := <c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> \u03c6.hom\u2083", "obtain \u27e8y\u2081, hy\u2082\u27e9 := <c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> \u03c6.hom\u2082", "obtain \u27e8y\u2081, hy\u2082\u27e9 := <c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> \u03c6.hom\u2083 y\u2082", "obtain \u27e8y\u2081, hy\u2082\u27e9 := <c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> _ y\u2082", "obtain \u27e8y\u2081, hy\u2082\u27e9 := <c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> \u03c6.hom\u2082 y\u2082", "obtain \u27e8y\u2081, hy\u2082\u27e9 := <c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> (\u03c6.hom\u2083) y\u2082", "obtain \u27e8y\u2081, hy\u2082\u27e9 := <c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> (\u03c6.hom\u2083 \u226b \u03c6.hom\u2083)", "obtain \u27e8y\u2081, hy\u2082\u27e9 := <c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> (<c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> \u03c6.hom\u2082) y\u2082"], "predictions2": ["obtain \u27e8x\u2081, hx\u2081\u27e9 := <c> {T : Triangle C} (hT : T \u2208 distTriang C) (hT' : T \u2208 distTriang C)\n    (h\u2081 : T \u2208 distTriang C) (h\u2082 : T \u2208 distTriang C) : T \u2208 distTriang C<", "obtain \u27e8x\u2081, hx\u2081\u27e9 := <c> {T : Triangle C} (hT : T \u2208 distTriang C) (hT' : T \u2208 distTriang C)\n    (h\u2081 : T \u2208 distTriang C) (h\u2082 : T \u2208 distTriang C) : T \u2208 distTriang C</", "obtain \u27e8x\u2081, hx\u2081\u27e9 := <c> {T : Triangle C} (hT : T \u2208 distTriang C) (hT' : T \u2208 distTriang C)\n    (h\u2081 : T \u2208 distTriang C) (h\u2082 : T \u2208 distTriang C) (h\u2083 : T \u2208 distTriang C) : T", "obtain \u27e8x\u2081, hx\u2081\u27e9 := <c> {T : Triangle C} (hT : T \u2208 distTriang C) (hT' : T \u2208 distTriang C)\n    (h\u2081 : T \u2208 distTriang C) (h\u2082 : T \u2208 distTriang C) : \u2203 (x\u2081 : C) (y\u2081 : ", "obtain \u27e8x\u2081, hx\u2081\u27e9 := <c> {T : Triangle C} (\u03c6 : T \u27f6 T) (hT : T \u2208 distTriang C)\n    (hT' : T \u2208 distTriang C) (hT' : T \u2208 distTriang C) : \u2203 (x\u2081 : X\u2081) (y\u2082 : Y\u2082", "obtain \u27e8x\u2081, hx\u2081\u27e9 := <c> {T : Triangle C} (hT : T \u2208 distTriang C) (hT' : T \u2208 distTriang C)\n    (h\u2081 : T \u2208 distTriang C) (h\u2082 : T \u2208 distTriang C) : \u2203 (x : C) (y : ", "obtain \u27e8x\u2081, hx\u2081\u27e9 := <c> {T : Triangle C} (hT : T \u2208 distTriang C) (hT' : T \u2208 distTriang C)\n    (h\u2081 : T \u2208 distTriang C) (h\u2082 : T \u2208 distTriang C) (h\u2083 : T \u2208 distTriang C) : T ", "obtain \u27e8x\u2081, hx\u2081\u27e9 := <c> {T : Triangle C} (hT : T \u2208 distTriang C) (hT' : T \u2208 distTriang C)\n    (h\u2081 : T \u2208 distTriang C) (h\u2082 : T \u2208 distTriang C) (h\u2083 : T \u2208 distTriang C) : "]}, {"state_before": "C : Type u_1\nD : Type u_2\nE : Type u_3\ninst\u271d\u00b9\u2070 : Category.{u_6, u_1} C\ninst\u271d\u2079 : Category.{u_7, u_2} D\ninst\u271d\u2078 : Category.{?u.50852, u_3} E\nF\u271d : C \u2964 D\nG : D \u2964 E\nA : Type u_4\nB : Type u_5\ninst\u271d\u2077 : AddMonoid A\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : HasShift C A\ninst\u271d\u2074 : HasShift D A\ninst\u271d\u00b3 : HasShift E A\ninst\u271d\u00b2 : HasShift C B\ninst\u271d\u00b9 : HasShift D B\nF : C \u2964 D\ninst\u271d : CommShift F B\nX : C\na b : B\neq :\n  F.map ((shiftFunctorAdd C a b).inv.app X) \u226b (commShiftIso F (a + b)).hom.app X =\n    (commShiftIso F b).hom.app ((shiftFunctor C a).obj X) \u226b\n      (shiftFunctor D b).map ((commShiftIso F a).hom.app X) \u226b (shiftFunctorAdd D a b).inv.app (F.obj X)\n\u22a2 F.map ((shiftFunctorComm C a b).hom.app X) =\n    (commShiftIso F b).hom.app ((shiftFunctor C a).obj X) \u226b\n      (shiftFunctor D b).map ((commShiftIso F a).hom.app X) \u226b\n        ((shiftFunctorAdd' D a b (a + b) \u22ef).inv.app (F.obj X) \u226b (shiftFunctorAdd' D b a (a + b) \u22ef).hom.app (F.obj X)) \u226b\n          (shiftFunctor D a).map ((commShiftIso F b).inv.app X) \u226b (commShiftIso F a).inv.app ((shiftFunctor C b).obj X)", "expanded_tactic": "simp only [<a>Functor.map_comp</a>, <c> (i j : A) :\n    shiftFunctorAdd' C i j (i+j) rfl = shiftFunctorAdd C i j</c>, <a>Category.assoc</a>,\n    \u2190 reassoc_of% eq, <c> (i j k : A) (h : i + j = k) :\n    shiftFunctorComm C i j = (shiftFunctorAdd' C i j k h).symm \u226a\u226b\n      shiftFunctorAdd' C j i k (by rw [add_comm j i, h])</c> C a b _ <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>]", "predictions0": ["simp only [<a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>]", "simp only [<a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>]", "simp only [<a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>]", "simp only [<a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>] at eq", "simp only [<a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>]", "simp only [<a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>]", "simp only [<a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>]", "simp only [<a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>]"], "predictions1": ["simp only [\u2190 <c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>]", "simp only [<a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>]", "simp only [<a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>,\n    <a>Functor.map_comp</a>]", "simp only [<a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>,\n    <a>Functor.map_comp</a>, <a>Functor.map_comp</a>]", "simp only [<a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>,\n    <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>]", "simp only [<a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>,\n    <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>]", "simp only [<a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>,\n    <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_id</a>]", "simp only [<a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>,\n    <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>, <a>Functor.map_comp</a>]"], "predictions2": ["simp only [<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>] at eq", "simp only [\u2190 <c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>] at eq", "simp only [<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>]", "simp only [<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>, <a>Iso.hom_inv_id_app_assoc</a>]", "simp only [\u2190 <c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> ((<c> (a b : \u03b1) : a + b - b = a</c> C a b).<a>hom</a> X)]", "simp only [\u2190 <c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> ((<c> (a b : \u03b1) : a + b - b = a</c> _ _).<a>map</a> X)]", "simp only [\u2190 <c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> ((<c> (a b : \u03b1) : a + b \u2245 a + b</c> _ _).<a>hom</a> X)]", "simp only [\u2190 <c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> ((<c> (a b : \u03b1) : a + b - b = a</c> _ _).<a>map</a> X)]"]}, {"state_before": "case e_f\nC : Type u_1\ninst\u271d : Category.{u_2, u_1} C\nK : Coverage C\nP : C\u1d52\u1d56 \u2964 Type w\nX\u271d : C\nS\u271d : Sieve X\u271d\nX : C\nR S : Sieve X\na\u271d\u00b9 : saturate K X R\na\u271d : \u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984, R.arrows f \u2192 saturate K Y (Sieve.pullback f S)\nY : C\nf : Y \u27f6 X\nH :\n  \u2200 {X : C},\n    \u2200 R \u2208 K.covering X,\n      IsSeparatedFor P R \u2227\n        \u2200 (x : FamilyOfElements P R), FamilyOfElements.Compatible x \u2192 \u2203 t, FamilyOfElements.IsAmalgamation x t\nH1 : \u2200 \u2983Y : C\u2984 (f : Y \u27f6 X), IsSeparatedFor P (Sieve.pullback f R).arrows\nH1' :\n  \u2200 \u2983Y : C\u2984 (f : Y \u27f6 X) (x : FamilyOfElements P (Sieve.pullback f R).arrows),\n    FamilyOfElements.Compatible x \u2192 \u2203 t, FamilyOfElements.IsAmalgamation x t\nH2 :\n  \u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984,\n    R.arrows f \u2192 \u2200 \u2983Y_1 : C\u2984 (f_1 : Y_1 \u27f6 Y), IsSeparatedFor P (Sieve.pullback f_1 (Sieve.pullback f S)).arrows\nH2' :\n  \u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984,\n    R.arrows f \u2192\n      \u2200 \u2983Y_1 : C\u2984 (f_1 : Y_1 \u27f6 Y) (x : FamilyOfElements P (Sieve.pullback f_1 (Sieve.pullback f S)).arrows),\n        FamilyOfElements.Compatible x \u2192 \u2203 t, FamilyOfElements.IsAmalgamation x t\nx : FamilyOfElements P (Sieve.pullback f S).arrows\nhx : FamilyOfElements.Compatible x\ny : \u2983Z : C\u2984 \u2192 (g : Z \u27f6 Y) \u2192 FamilyOfElements P (Sieve.pullback (\ud835\udfd9 Z) (Sieve.pullback (g \u226b f) S)).arrows :=\n  fun Z g ZZ gg hgg => x (gg \u226b g) \u22ef\nhy : \u2200 \u2983Z : C\u2984 (g : Z \u27f6 Y), FamilyOfElements.Compatible (y g)\nz : \u2983Z : C\u2984 \u2192 \u2983g : Z \u27f6 Y\u2984 \u2192 (Sieve.pullback f R).arrows g \u2192 P.obj (Opposite.op Z)\nhz : \u2200 \u2983Z : C\u2984 \u2983g : Z \u27f6 Y\u2984 (hg : (Sieve.pullback f R).arrows g), FamilyOfElements.IsAmalgamation (y g) (z hg)\nq : FamilyOfElements P (Sieve.pullback f R).arrows := fun Z g hg => z hg\nY\u2081 Y\u2082 Z : C\ng\u2081 : Z \u27f6 Y\u2081\ng\u2082 : Z \u27f6 Y\u2082\nf\u2081 : Y\u2081 \u27f6 Y\nf\u2082 : Y\u2082 \u27f6 Y\nh\u2081 : (Sieve.pullback f R).arrows f\u2081\nh\u2082 : (Sieve.pullback f R).arrows f\u2082\nh : g\u2081 \u226b f\u2081 = g\u2082 \u226b f\u2082\nZZ : C\ngg : ZZ \u27f6 Z\nhgg : (Sieve.pullback g\u2081 (Sieve.pullback (f\u2081 \u226b f) S)).arrows gg\n\u22a2 (gg \u226b g\u2081) \u226b f\u2081 = (gg \u226b g\u2082) \u226b f\u2082", "expanded_tactic": "simp only [<a>Category.assoc</a>, h]", "predictions0": ["simp only [\u2190 <a>Category.assoc</a>, h]", "simp only [<a>Category.assoc</a>, h]", "simp only [\u2190 <a>CategoryTheory.Category.assoc</a>, h]", "simp [reassoc_of% h]", "simp only [<a>Category.assoc</a>, <a>Category.assoc</a>, h]", "simp only [<a>Category.assoc</a>, h, <a>Category.assoc</a>]", "simp [h]", "simp only [<a>CategoryTheory.Category.assoc</a>, h]"], "predictions1": ["simp only [<a>Category.assoc</a>, h]", "simp only [<a>assoc</a>, h]", "rw [<a>assoc</a>, h]", "simp only [<a>Category.assoc</a>, <a>Category.assoc</a>, h]", "simp only [<a>assoc</a>, <a>Category.assoc</a>, h]", "simp only [reassoc_of% h, <a>Category.assoc</a>, h]", "simp only [<a>Category.assoc</a>, \u2190 <a>Category.assoc</a>, h]", "simp only [<a>Category.assoc</a>, h, <a>Category.assoc</a>]"], "predictions2": ["simp only [<a>Category.assoc</a>, h]", "simp only [<a>Category.assoc</a>, <a>Category.assoc</a>, h]", "simp only [<a>Category.assoc</a>, <c> (f : X \u27f6 Y) [I : IsIso f] : f \u226b inv f = \ud835\udfd9 X</c>, h]", "simp only [<a>Category.assoc</a>, <c> (f : X \u27f6 Y) [I : IsIso f] : f \u226b inv f = \ud835\udfd9 X</c>]", "simp only [<a>Category.assoc</a>, <c> {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) : f \u226b g = f \u226b h \u2194 g = h</c>]", "simp only [<a>Category.assoc</a>, <c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).arrows = g.arrows \u2194 f \u226b g = f</c>]", "simp only [<a>Category.assoc</a>, <c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).arrows = f \u226b (g \u226b f)</c>]", "simp only [<a>assoc</a>, <c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).arrows = g.arrows \u2194 f \u226b g = f</c>]"]}, {"state_before": "J : Type u\ninst\u271d\u00b9 : Category.{u_1, u} J\nF : J \u2964 Type v\ni j\u271d k : J\ns : Set (F.obj i)\ninst\u271d : IsCofilteredOrEmpty J\nh : IsMittagLeffler F\nj j\u2081 : J\ng\u2081 : j\u2081 \u27f6 i\nf\u2081 : j\u2081 \u27f6 j\nj\u2082 : J\nf\u2082 : j\u2082 \u27f6 j\u2081\nh\u2082 : eventualRange F j\u2081 = range (F.map f\u2082)\nj\u2083 : J\nf\u2083 : j\u2083 \u27f6 j\u2082\nx : F.obj j\u2082\nhx : x \u2208 \u22c2 f, F.map f \u207b\u00b9' s\n\u22a2 F.map f\u2082 x \u2208 eventualRange F j\u2081", "expanded_tactic": "rw [h\u2082]", "predictions0": ["rw [h\u2082]", "rw [h\u2082] at hx", "rwa [h\u2082]", "rw [h\u2082, <c> {x : \u03b1} {s : \u03b9 \u2192 Set \u03b1} : (x \u2208 \u22c2 i, s i) \u2194 \u2203 i, x \u2208 s i</c>]", "rw [h\u2082, <c> {x : \u03b1} {s : \u03b9 \u2192 Set \u03b1} : (x \u2208 \u22c2 i, s i) \u2194 \u2203 i, x \u2208 s i</c>] at hx", "rw [h\u2082, <c> {x : \u03b1} {s : Set \u03b1} : (x \u2208 \u22c2 i, s i) \u2194 \u2203 i, x \u2208 s i</c>]", "rw [h\u2082, <c> {x : \u03b1} {s : \u03b9 \u2192 Set \u03b1} : (x \u2208 \u22c2 i, s i) \u2194 \u2203 i, x \u2208 s</c>]", "rw [h\u2082, <c> {x : \u03b1} {s : \u03b9 \u2192 Set \u03b1} : (x \u2208 \u22c2 i, s i) \u2194 \u2203 i, x \u2208 s</c>] at hx"], "predictions1": ["rw [h\u2082]", "rw [h\u2082, <c> {x : \u03b1} {s : \u03b9 \u2192 Set \u03b1} : (x \u2208 \u22c2 i, s i) \u2194 \u2200 i, x \u2208 s i</c>]", "rw [h\u2082, <c> {x : \u03b1} {s : \u03b9 \u2192 Set \u03b1} : (x \u2208 \u22c2 i, s i) \u2194 \u2200 i, x \u2208 s i</c>] at hx", "exact <c> {x : \u03b1} {s : \u03b9 \u2192 Set \u03b1} : (x \u2208 \u22c2 i, s i) \u2194 \u2200 i, x \u2208 s i</c>.1 hx", "rw [h\u2082, <c> {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} {a : \u03b1} : a \u2208 f \u207b\u00b9' s \u2194 f a \u2208 s</c>]", "rw [h\u2082, <c> {f : \u03b1 \u2192 \u03b2} {s : \u03b9 \u2192 Set \u03b2} {a : \u03b1} : a \u2208 f \u207b\u00b9' s \u2194 f a \u2208 s</c>]", "simp only [h\u2082, <c> {x : \u03b1} {s : \u03b9 \u2192 Set \u03b1} : (x \u2208 \u22c2 i, s i) \u2194 \u2200 i, x \u2208 s i</c>]", "simp only [h\u2082, <c> {x : \u03b1} {s : \u03b9 \u2192 Set \u03b1} : (x \u2208 \u22c2 i, s i) \u2194 \u2200 i, x \u2208 s i</c>] at hx"], "predictions2": ["rw [h\u2082, <c> {x : \u03b1} {s : \u03b9 \u2192 Set \u03b1} : (x \u2208 \u22c2 i, s i) \u2194 \u2200 i, x \u2208 s i</c>]", "rw [h\u2082]", "rw [h\u2082, <c> {x : \u03b1} {s : \u03b9 \u2192 Set \u03b1} : (x \u2208 \u22c2 i, s i) \u2194 \u2200 i, x \u2208 s i</c>] at hx", "exact <c> {x : \u03b1} {s : \u03b9 \u2192 Set \u03b1} : (x \u2208 \u22c2 i, s i) \u2194 \u2200 i, x \u2208 s i</c>.1 hx", "rw [h\u2082] at hx", "rw [h\u2082, <c> {f : \u03b1 \u2192 \u03b2} {s : \u03b9 \u2192 Set \u03b2} {a : \u03b1} : a \u2208 f \u207b\u00b9' s \u2194 f a \u2208 s</c>]", "exact <c> {x : \u03b3} {s : \u2200 i, \u03ba i \u2192 Set \u03b3} : (x \u2208 \u22c2 (i) (j), s i j) \u2194 \u2200 i j, x \u2208 s i j</c>.1 hx", "rw [h\u2082, <c> {f : \u03b1 \u2192 \u03b2} {s : \u03b9 \u2192 Set \u03b2} : (f \u207b\u00b9' \u22c2 i, s i) = \u22c2 i, f \u207b\u00b9' s i</c>]"]}, {"state_before": "\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nstart stop : Nat\nh : i < size (extract as start stop)\n\u22a2 as[start + i - size #[]] = as[start + i]\n\ncase hge\n\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nstart stop : Nat\nh : i < size (extract as start stop)\n\u22a2 i \u2265 size #[]", "expanded_tactic": "rfl", "predictions0": ["rfl", "rw [<c></c>]", "rw [<a>add_comm</a>]", "rw [<c></c>, <c></c>]", "rw [<a>add_comm</a>, <a>add_comm</a>]", "rw [<a>add_comm</a>, <a>sub_add_cancel</a>]", "rw [<a>add_comm</a>, <a>add_assoc</a>]", "rw [<a>add_comm</a>, <a>add_assoc</a>, <a>add_comm</a>]"], "predictions1": ["rfl", "rw [<c> (n m k : Nat) : n + m - k = n + (m + k)</c>]", "rw [<c> (n m k : Nat) : n - m - k = n - (m + k)</c>]", "rw [<c> (n m k : Nat) : n + m - k = n + (m - k)</c>]", "simp only [<c> (as : Array \u03b1) (start stop) : Array \u03b1</c>]", "rw [<c> (n m k : Nat) : n + m - k = n + (m + k)</c>, <c> (n m k : Nat) : n + m - k = n + (m + k)</c>]", "simp only [<c> (as : Array \u03b1) (start stop) : Array \u03b1</c>, <c> (as : Array \u03b1) (start stop) : Array \u03b1</c>]", "rw [<c> (n m k : Nat) : n + m - k = n + (m + k)</c>, <c> (n m : Nat) : n + m - k = n + (m + k)</c>]"], "predictions2": ["rfl", "rw [<c> (as : Array \u03b1) (start stop : Nat) :\n    (as.extract stop).size = as.size</c>]", "rw [<c> (as : Array \u03b1) (start stop : Nat) :\n    (as.extract stop).size = as.size + 1</c>]", "simp only [<c> (as : Array \u03b1) (start stop : Nat) :\n    (as.extract stop).size = as.size</c>]", "simp only [<c> (as : Array \u03b1) (start stop : Nat) :\n    (as.extract stop).size = as.size + 1</c>]", "rw [<c> (as : Array \u03b1) (start stop : Nat) :\n    (as.extract start stop).size = as.size</c>]", "rw [<c> (as bs : Array \u03b1) (start stop : Nat) :\n    (as.extract stop).size = as.size + bs.size</c>]", "simp only [<c> (as : Array \u03b1) (start stop : Nat) :\n    (as.extract start stop).size = as.size</c>]"]}, {"state_before": "case intro\nJ : Type u_1\ninst\u271d : Category.{u_2, u_1} J\nK : J \u2964 Type u\nc : Cocone K\nhc : IsColimit c\nlc : Cocone (K \u22d9 uliftFunctor.{v, u})\nx y : lc.pt\nhn : x \u2260 y\nj : J\nz : K.obj j\nhx : lc.\u03b9.app j { down := z } = x\nhy : lc.\u03b9.app j { down := z } = y\n\u22a2 False", "expanded_tactic": "exact hn (hx \u25b8 hy)", "predictions0": ["exact hn hx", "exact hn hy", "exact hn (hx \u25b8 hy)", "rw [hx, hy] at hn", "exact hn hx.symm", "exact hn (hx.symm.trans hy)", "rw [\u2190 hx, hy] at hn", "exact hn (hy.symm.trans hy)"], "predictions1": ["exact hn <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "exact hn hy", "exact hn (hx \u25b8 hy)", "exact hn (hx.symm.trans hy)", "exact hn hx.symm", "exact hn (hy.symm.trans hy)", "exact hn (hx.symm \u25b8 hy)", "exact hn (hy.symm.trans hy.symm)"], "predictions2": ["exact hn <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "exact hn (hx.symm.trans hy)", "exact hn hy", "exact hn (hx \u25b8 hy)", "exact hn (hy.symm.trans hy)", "exact hn <c> {\u03b1 : Sort u} {a b : \u03b1} (h : Eq a b) : Eq b a</c>", "exact hn (hx.symm \u25b8 hy)", "exact hn (hy.symm.subst <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>)"]}, {"state_before": "case mpr.transitive\nC : Type u_1\ninst\u271d : Category.{u_2, u_1} C\nK : Coverage C\nP : C\u1d52\u1d56 \u2964 Type w\nH : \u2200 {X : C}, \u2200 R \u2208 K.covering X, IsSheafFor P R\nX\u271d : C\nS\u271d : Sieve X\u271d\nX : C\nR S : Sieve X\na\u271d\u00b9 : saturate K X R\na\u271d : \u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984, R.arrows f \u2192 saturate K Y (Sieve.pullback f S)\nH1 : \u2200 \u2983Y : C\u2984 (f : Y \u27f6 X), IsSheafFor P (Sieve.pullback f R).arrows\nH2 :\n  \u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984,\n    R.arrows f \u2192 \u2200 \u2983Y_1 : C\u2984 (f_1 : Y_1 \u27f6 Y), IsSheafFor P (Sieve.pullback f_1 (Sieve.pullback f S)).arrows\n\u22a2 \u2200 \u2983Y : C\u2984 (f : Y \u27f6 X), IsSheafFor P (Sieve.pullback f S).arrows", "expanded_tactic": "intro Y f", "predictions0": ["exact fun Y f => H1 f", "exact fun Y f \u21a6 H1 f", "intro Y f", "exact fun Y f => H2 f (H1 f)", "exact H1", "exact H1 f", "exact fun Y f \u21a6 H2 f (H1 f)", "exact fun Y f => H2 f (H1 \u27e8Y, f, h\u27e9)"], "predictions1": ["intro Y f", "exact fun Y f => H1 f", "exact fun Y f => H1 f (H1 f)", "exact fun Y f => H2 f (H1 f)", "apply H1", "rintro Y f", "exact fun Y f => H1 fun Y f => H2 f (S.pullback.map f)", "exact fun Y f =>\n      (H1 f).<c> {P : C\u1d52\u1d56 \u2964 Type w} (P : C\u1d52\u1d56 \u2964 Type w)\n    (H2 : \u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984, R.pullback f \u2192 P (Sieve.pullback f S))\n    (H1 : \u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984, R.pullback f S \u2192 P (Sieve.pullback f S))\n    (H2 : \u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984, R.pullback f S \u2192 P (Sieve.pullback f S))\n    (H1 : \u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984, R.pullback f S \u2192 P (Sieve.pullback f S))\n    (H2 : \u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984, R.pullback f S \u2192 P (Sieve.pullback f S))\n    (H1 : \u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984, R.pullback f S \u2192 P (Sieve.pullback f S))\n    (H2 : \u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984, R.pullback f S \u2192 P (Sieve.pullback f S))\n    (H1 : \u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984, R.pullback f S \u2192 P (Sieve.pullback f S))\n    (H2 : \u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984, R.pullback f S \u2192 P (Sieve.pullback f S))\n    (H1 : \u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984, R.pullback f S \u2192 P (Sieve.pullback f S))\n    (H2 : \u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984, R.pullback f S "], "predictions2": ["exact fun Y f => (H1 f).<c> {C : Sort u} (h : False) : C</c>", "exact fun Y f => H1 f", "exact fun Y f hf => (H1 hf).<c> {C : Sort u} (h : False) : C</c>", "apply H1", "exact fun Y f => (H1 f).<c> {p : \u03b1 \u2192 Prop} (P : \u2203 a, p a) : p P.choose</c>.1", "exact fun Y f => (H1 f).<c> {p : \u03b1 \u2192 Prop} (P : \u2203 a, p a) : p P.choose</c>.2", "exact fun Y f => (H1 f).<c> {p : \u03b1 \u2192 Prop} (P : \u2203 a, p a) : p P.choose</c>", "exact fun Y f => (H1 f).<c> {p : \u03b1 \u2192 Prop} (P : \u2203 a, p a) : p P.choose</c>.1 (H2 f)"]}, {"state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\ns : Set \u03b1\nt : Set \u03b2\nf\u271d : Filter \u03b1\ng : Filter \u03b2\na : \u03b1\nf : Filter \u03b2\n\u22a2 pure a \u00d7\u02e2 f = map (Prod.mk a) f", "expanded_tactic": "rw [<c> : f \u00d7\u02e2 g = (f.map Prod.mk).seq g</c>, <a>map_pure</a>, <c> (g : \u03b1 \u2192 \u03b2) (f : Filter \u03b1) : seq (pure g) f = f.map g</c>]", "predictions0": ["rfl", "rw [<c> (a : \u03b1) : map (Prod.mk a) f = map (Prod.mk a) f</c>]", "rw [<c> (a : \u03b1) : map (Prod.mk a) f = map (Prod.mk a) f</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>]", "rw [<c> (a : \u03b1) : map (Prod.mk a) f = map (Prod.mk a) f</c>, <c> (a : \u03b1) : map (Prod.mk a) f = map (Prod.mk a) f</c>]", "rw [<c> (a : \u03b1) : map (Prod.mk a) f = map (Prod.mk a) f</c>, <c> : map (Prod.mk a) f = map (Prod.mk a) f</c>]", "rw [<c> (a : \u03b1) : map (Prod.mk a) f = map (Prod.mk a) f</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>]", "rw [<c> (a : \u03b1) : map (Prod.mk a) f = map (Prod.mk a) f</c>, <c> (f : Filter \u03b1) : map (Prod.mk a) f = map (Prod.mk a) f</c>]", "rw [<c> (a : \u03b1) : map (Prod.mk a) f = map (Prod.mk a) f</c>, <c> (a : \u03b1) : map (Prod.mk a) f = pure a \u00d7\u02e2 f</c>]"], "predictions1": ["rw [<c> (a : \u03b1) (f : Filter \u03b2) : Filter (\u03b1 \u00d7 \u03b2)</c>, <c> (a : \u03b1) (a : \u03b1) : map (Prod.mk a) f = map (Prod.mk a) f</c>]", "rw [<c> (a : \u03b1) (f : Filter \u03b2) : map (Prod.mk a) f = map (Prod.mk a) f</c>, <c> (a : \u03b1) (f : Filter \u03b2)</c>]", "rw [<c> (a : \u03b1) (f : Filter \u03b2) : Filter (\u03b1 \u00d7 \u03b2)</c>, <c> (a : \u03b1) (f : Filter \u03b2) : Filter (\u03b1 \u00d7 \u03b2)</c>]", "rw [<c> (a : \u03b1) (f : Filter \u03b2) : Filter (\u03b1 \u00d7 \u03b2)</c>, <c> (f : Filter \u03b1) (g : Filter \u03b2) : Filter (\u03b1 \u00d7 \u03b2)</c>]", "rw [<c> (a : \u03b1) (f : Filter \u03b2) : map (Prod.mk a) f = map (Prod.mk a) f</c>, <c> (a : \u03b1) (a : \u03b1) : map (Prod.mk a) f = map (Prod.mk a) f</c>]", "rw [<c> (a : \u03b1) (f : Filter \u03b2) : map (Prod.mk a) f = map (Prod.mk a) f</c>, <c> (a : \u03b1) (f : Filter \u03b2) : map (Prod.mk a) f = map (Prod.mk a) f</c>]", "rw [<c> (a : \u03b1) (f : Filter \u03b2) : map (Prod.mk a) f = map (Prod.mk a) f</c>, <c> (a : \u03b1) (f : Filter \u03b2) : map (Prod.mk a) f = map f f</c>]", "rw [<c> (a : \u03b1) (f : Filter \u03b2) : Filter (\u03b1 \u00d7 \u03b2)</c>, <c> (a : \u03b1) (a : \u03b1) : map (Prod.mk a) f = map (Prod.mk a) f</c>, <c> (a : \u03b1) : map (Prod.mk a) f = map (Prod.mk a) f</c>]"], "predictions2": ["rw [<c> (a : \u03b1) (f : Filter \u03b2) : map (Prod.mk a) f = map (Prod.mk a) f</c>, <c> (a : \u03b1) : \ud835\udcdf {a} = pure a</c>]", "rw [<c> (a : \u03b1) (f : Filter \u03b2) : map (Prod.mk a) f = map (Prod.mk a) f</c>, <c> (a : \u03b1) : pure a = pure a</c>]", "rw [<c> (a : \u03b1) (f : Filter \u03b2) : Filter (\u03b1 \u00d7 \u03b2)</c>, <c> (a : \u03b1) (f : Filter \u03b2) : map (Prod.mk a) f = map (Prod.mk a) f</c>]", "rw [<c> (a : \u03b1) (f : Filter \u03b2) : Filter (\u03b1 \u00d7 \u03b2)</c>, <c> (a : \u03b1) (f : Filter \u03b2) : map (Prod.mk a) f = pure a</c>]", "rw [<c> (a : \u03b1) (f : Filter \u03b2) : map (Prod.mk a) f = map (Prod.mk a) f</c>, <c> {f : Filter \u03b1} : map f (\ud835\udcdf s) = \ud835\udcdf (f \u207b\u00b9' s)</c>]", "rw [<c> (a : \u03b1) (f : Filter \u03b2) : Filter (\u03b1 \u00d7 \u03b2)</c>, <c> (a : \u03b1) (f : Filter \u03b2) : map (Prod.mk a) f = map Prod.mk f</c>]", "rw [<c> (a : \u03b1) (f : Filter \u03b2) : Filter (\u03b1 \u00d7 \u03b2)</c>, <c> (a : \u03b1) (f : Filter \u03b2) : map (Prod.mk a) f = map f f</c>]", "rw [<c> (a : \u03b1) (f : Filter \u03b2) : map (Prod.mk a) f = map (Prod.mk a) f</c>, <c> (a : \u03b1) (f : Filter \u03b2) : map (Prod.mk a) f = f</c>]"]}, {"state_before": "case inr.intro.intro.intro.refine_1\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\nr\u271d r : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : IsRefl \u03b1 r\ninst\u271d : IsTrans \u03b1 r\ns : Set \u03b1\nh : PartiallyWellOrderedOn s r\nh\u271d : Nonempty \u03b1\ninhabited_h : Inhabited \u03b1\nf : \u2115 \u2192 List \u03b1\nhf1 : IsBadSeq (List.SublistForall\u2082 r) {l | \u2200 x \u2208 l, x \u2208 s} f\nhf2 : \u2200 (n : \u2115), IsMinBadSeq (List.SublistForall\u2082 r) List.length {l | \u2200 x \u2208 l, x \u2208 s} n f\nhnil : \u2200 (n : \u2115), f n \u2260 []\nthis : \u2200 (n : \u2115), List.headI (f n) \u2208 s\ng : \u2115 \u21aao \u2115\nhg : \u2200 (m n : \u2115), m \u2264 n \u2192 r (List.headI (f (g m))) (List.headI (f (g n)))\n\u22a2 List.length ((fun n => if n < g 0 then f n else List.tail (f (g (n - g 0)))) (g 0)) < List.length (f (g 0))", "expanded_tactic": "simp only [<c> {c : Prop} {h : Decidable c} (hnc : \u00acc) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = e</c> (<c> : \u2200 a : \u03b1, \u00aca < a</c> (g 0)), <c> (a : \u03b1) : a - a = 0</c>]", "predictions0": ["simp only [<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>]", "simp only [<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>]", "simp only [<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>]", "simp only [<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>]", "simp only [<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} (a b : \u03b1) : (a \u2260 b) = \u00ac (a = b)</c>]", "simp only [<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>]", "simp only [<c> {\u03b1 : Sort u} (a b : \u03b1) : ite False t e = b</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>]", "simp only [<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} (a b : \u03b1) : (a \u2260 b) = \u00ac (a = b)</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>]"], "predictions1": ["simp only [<c> {c : Prop} {h : Decidable c} (hnc : \u00acc) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = e</c> hnil]", "simp only [<c> {c : Prop} {h : Decidable c} (hnc : \u00acc) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = e</c> hnil, <c> {c : Prop} {h : Decidable c} (hnc : \u00acc) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = e</c> hnil]", "simp only [<c> {c : Prop} {h : Decidable c} (hnc : \u00acc) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = e</c>, <c> {c : Prop} {h : Decidable c} (hnc : \u00acc) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = e</c> hnil]", "simp only [<c> {c : Prop} {h : Decidable c} (hnc : \u00acc) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = e</c> (hnil _), <c> {c : Prop} {h : Decidable c} (hnc : \u00acc) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = e</c> hnil]", "simp only [<c> {c : Prop} {h : Decidable c} (hnc : \u00acc) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = e</c> (hnil _), <c> {c : Prop} {h : Decidable c} (hnc : \u00acc) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = e</c> (hnil _)]", "simp only [<c> {c : Prop} {h : Decidable c} (hnc : \u00acc) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = e</c> hnil, <c> {c : Prop} {h : Decidable c} (hnc : \u00acc) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = e</c> (hnil _)]", "simp only [<c> {c : Prop} {h : Decidable c} (hnc : \u00acc) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = e</c> hnil, <c> {c : Prop} {h : Decidable c} (hnc : \u00acc) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = e</c>, <c> {c : Prop} {h : Decidable c} (hnc : \u00acc) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = e</c> hnil]", "simp only [<c> {c : Prop} {h : Decidable c} (hnc : \u00acc) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = e</c> hnil, <c> {c : Prop} {h : Decidable c} (hnc : \u00acc) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = e</c>, <c> {c : Prop} {h : Decidable c} (hc : c) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = t</c> hnil]"], "predictions2": ["simp only [<c> {c : Prop} {h : Decidable c} (hc : c) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = t</c> hnil]", "simp only [<c> {c : Prop} {h : Decidable c} (hc : c) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = t</c>]", "simp only [<c> {c : Prop} {h : Decidable c} (hnc : \u00acc) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = e</c> hnil]", "simp only [<c> (a b : \u03b1) : (if False then a else b) = b</c>]", "simp only [<c> {c : Prop} {h : Decidable c} (hc : c) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = t</c> (hnil _)]", "simp only [<c> {a b : \u03b1} : a = b \u2194 b = a</c>]", "simp only [<c> {c : Prop} {h : Decidable c} (hnc : \u00acc) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = e</c> (hnil _)]", "simp only [<c> {c : Prop} {h : Decidable c} (hc : c) {\u03b1 : Sort u} {t : c \u2192 \u03b1} {e : \u00ac c \u2192 \u03b1} : (dite c t e) = t hc</c>]"]}, {"state_before": "case mk.eq.intro.mk.intro.mk.refine'_1.a\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : IsCofilteredOrEmpty C\n\u03b1 : Type w\nf : \u03b1 \u2192 C\nj : C\nn : \u2115\nx : (CategoryTheory.IsCofiltered.CofilteredClosureSmall.bundledAbstractCofilteredClosure f n).fst\nhj\u2081 :\n  CofilteredClosure f\n    (CategoryTheory.IsCofiltered.CofilteredClosureSmall.abstractCofilteredClosureRealization f { fst := n, snd := x })\nm : \u2115\ny : (CategoryTheory.IsCofiltered.CofilteredClosureSmall.bundledAbstractCofilteredClosure f m).fst\nhj\u2082 :\n  CofilteredClosure f\n    (CategoryTheory.IsCofiltered.CofilteredClosureSmall.abstractCofilteredClosureRealization f { fst := m, snd := y })\ng g' :\n  CategoryTheory.IsCofiltered.CofilteredClosureSmall.abstractCofilteredClosureRealization f { fst := n, snd := x } \u27f6\n    CategoryTheory.IsCofiltered.CofilteredClosureSmall.abstractCofilteredClosureRealization f { fst := m, snd := y }\n\u22a2 n \u2264 max n m\n\ncase mk.eq.intro.mk.intro.mk.refine'_2.a\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : IsCofilteredOrEmpty C\n\u03b1 : Type w\nf : \u03b1 \u2192 C\nj : C\nn : \u2115\nx : (CategoryTheory.IsCofiltered.CofilteredClosureSmall.bundledAbstractCofilteredClosure f n).fst\nhj\u2081 :\n  CofilteredClosure f\n    (CategoryTheory.IsCofiltered.CofilteredClosureSmall.abstractCofilteredClosureRealization f { fst := n, snd := x })\nm : \u2115\ny : (CategoryTheory.IsCofiltered.CofilteredClosureSmall.bundledAbstractCofilteredClosure f m).fst\nhj\u2082 :\n  CofilteredClosure f\n    (CategoryTheory.IsCofiltered.CofilteredClosureSmall.abstractCofilteredClosureRealization f { fst := m, snd := y })\ng g' :\n  CategoryTheory.IsCofiltered.CofilteredClosureSmall.abstractCofilteredClosureRealization f { fst := n, snd := x } \u27f6\n    CategoryTheory.IsCofiltered.CofilteredClosureSmall.abstractCofilteredClosureRealization f { fst := m, snd := y }\n\u22a2 m \u2264 max n m", "expanded_tactic": "exacts [<c> ( a b : Nat) : a \u2264 max a b</c> _ _, <c> (a b : Nat) : b \u2264 max a b</c> _ _]", "predictions0": ["exacts [<c> (n m : Nat) : m \u2264 max n m</c> _ _, <c> (n m : Nat) : m \u2264 max n m</c> _ _]", "exacts [<c> (n m : Nat) : n \u2264 max n m</c> _ _, <c> (n m : Nat) : m \u2264 max n m</c> _ _]", "exacts [<c> (n m : Nat) : n \u2264 max n m</c> _ _, <c> (n m : Nat) : n \u2264 max n m</c> _ _]", "exacts [<c> (n : \u2115) : n \u2264 max n m</c> _ _, <c> (n m : Nat) : m \u2264 max n m</c> _ _]", "exacts [<c> (n m : Nat) : m \u2264 max n m</c> _ _, <c> (n m : Nat) : n \u2264 max n m</c> _ _]", "exacts [<c> (n m : Nat) : m \u2264 max n m</c> _ _, <c> (n m : Nat) : m \u2264 max m n</c> _ _]", "exacts [<c> (n m : Nat) : n \u2264 max n m</c> _ _, <c> (n m : Nat) : n \u2264 max m n</c> _ _]", "exacts [<c> (n m : Nat) : m \u2264 max n m</c> _ _, <c> {n m : Nat} : n \u2264 max n m</c> _ _]"], "predictions1": ["exacts [<c> : a \u2264 a</c>, <c> : a \u2264 a</c>]", "exacts [<c> (a b : \u03b1) : a \u2264 max a b</c> _ _, <c> (a b : \u03b1) : a \u2264 max a b</c> _ _]", "apply <c> (a b : \u03b1) : a \u2264 max a b</c>", "all_goals exact <c> : a \u2264 a</c>", "all_goals exact <c> (a b : \u03b1) : a \u2264 max a b</c> _ _", "apply <c> : a \u2264 a</c>", "exacts [<c> : a \u2264 a</c>, <c> (a b : \u03b1) : a \u2264 max a b</c> _ _]", "exacts [<c> (a b : \u03b1) : a \u2264 max a b</c> _ _, <c> (a b : \u03b1) : max a b \u2264 max a b</c> _ _]"], "predictions2": ["exacts [<c> (a b : \u03b1) : a \u2264 max a b</c> _ _, <c> (a b : \u03b1) : a \u2264 max a b</c> _ _]", "apply <c> (a b : \u03b1) : a \u2264 max a b</c>", "exacts [<c> : a \u2264 a</c>, <c> (a b : \u03b1) : a \u2264 max a b</c> _ _]", "exacts [<c> : a \u2264 a</c>, <c> : a \u2264 a</c>]", "all_goals apply <c> (a b : \u03b1) : a \u2264 max a b</c>", "apply <c> : a \u2264 a</c>", "exacts [<c> : a \u2264 a</c>, <c> (a b : \u03b1) : a \u2264 max a b</c> _ _, <c> (a b : \u03b1) : a \u2264 max a b</c> _ _]", "apply <c> : \u2200 {a b c : \u03b1}, a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c</c>"]}, {"state_before": "case mp.intro.refine'_1.h\u2082\nJ : Type v'\ninst\u271d\u00b9 : Category.{u', v'} J\nC : Type u\ninst\u271d : Category.{v, u} C\nW X\u271d Y\u271d Z : C\nf\u271d : W \u27f6 X\u271d\ng : W \u27f6 Y\u271d\nh\u271d : X\u271d \u27f6 Z\ni : Y\u271d \u27f6 Z\nX E Y YE : C\nc : BinaryCofan X E\nhc : IsColimit c\nf : X \u27f6 Y\niY : Y \u27f6 YE\nfE : c.pt \u27f6 YE\nH : CommSq f (BinaryCofan.inl c) iY fE\nh : IsColimit (BinaryCofan.mk (BinaryCofan.inr c \u226b fE) iY)\ns : PushoutCocone f (BinaryCofan.inl c)\n\u22a2 BinaryCofan.inr c \u226b fE \u226b h.desc (BinaryCofan.mk (BinaryCofan.inr c \u226b PushoutCocone.inr s) (PushoutCocone.inl s)) =\n    BinaryCofan.inr c \u226b s.\u03b9.app WalkingSpan.right", "expanded_tactic": "rw [\u2190 <a>Category.assoc</a>]", "predictions0": ["simp [H.w]", "rw [\u2190 H.w_assoc]", "rw [\u2190 <a>Category.assoc</a>, H.w]", "simp only [\u2190 <a>Category.assoc</a>]", "rw [\u2190 <a>Category.assoc</a>, <a>Category.assoc</a>, H.w]", "simp only [<a>Category.assoc</a>, <a>Category.assoc</a>]", "simp only [<a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>]", "simp only [<a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>]"], "predictions1": ["exact H.w _ \u226b H.w", "rw [\u2190 <a>Category.assoc</a>, \u2190 H.w, <a>Category.assoc</a>, H.w]", "rw [\u2190 <c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> _ <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>]", "rw [\u2190 <a>Category.assoc</a>, <c> {W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] (h : W \u27f6 X)\n    (k : W \u27f6 Y) (w : h \u226b f = k \u226b g) : k \u226b f = k \u226b g</c>]", "rw [\u2190 <a>Category.assoc</a>, <c> {W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] (h : W \u27f6 X)\n    (k : W \u27f6 Y) (w : h \u226b f = k \u226b g) : k \u226b f = k \u226b g</c>, H.w]", "rw [\u2190 <a>Category.assoc</a>, <c> {W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] (h : W \u27f6 X)\n    (k : W \u27f6 Y) (w : h \u226b f = k \u226b g) : k \u226b f = k \u226b g</c> _ _ <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>]", "rw [\u2190 <a>Category.assoc</a>, <c> {W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] (h : W \u27f6 X)\n    (k : W \u27f6 Y) (w : h \u226b f = k \u226b g) : k \u226b f = k \u226b g</c> _ _ _ <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>]", "rw [\u2190 <a>Category.assoc</a>, <c> {W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] (h : W \u27f6 X)\n    (k : W \u27f6 Y) (w : h \u226b f = k \u226b g) : k \u226b f = k \u226b g</c> h.fac _ <a>WalkingSpan.right</a>]"], "predictions2": ["exact (<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> _ <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>).1 H.w", "rw [\u2190 <c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> _ <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>]", "exact (<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> _ <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>).1 H", "exact (<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> _).<a>mp</a> H.w", "exact (h.fac (<c> {X Y : C} (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> _)).1 H.w", "exact (<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> _ _).<a>mp</a> H.w", "exact (<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> _).<a>mp</a> H.w]", "exact (<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> _ _).<a>mpr</a> H.w"]}, {"state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d : MonoidalCategory C\nM N P : Mon_ C\n\u22a2 (((\u03bb_ (\ud835\udfd9_ C)).inv \u2297 \ud835\udfd9 (\ud835\udfd9_ C)) \u226b ((M.one \u2297 N.one) \u2297 P.one)) \u226b (\u03b1_ M.X N.X P.X).hom =\n    M.one \u2297 (\u03bb_ (\ud835\udfd9_ C)).inv \u226b (N.one \u2297 P.one)", "expanded_tactic": "slice_lhs 2 3 => rw [<a>associator_naturality</a>]", "predictions0": ["simp", "symm", "slice_lhs 2 3 => rw [\u2190 <a>Category.id_comp</a> (M.one \u2297 N.one)]", "slice_lhs 2 3 => rw [\u2190 <a>Category.assoc</a>, <a>Category.assoc</a>]", "slice_lhs 2 3 => rw [\u2190 <a>Category.assoc</a>, \u2190 <a>Category.assoc</a>]", "slice_lhs 2 3 => rw [\u2190 <a>Category.assoc</a>, <a>Category.assoc</a>, <a>Category.assoc</a>]", "slice_lhs 2 3 => rw [\u2190 <a>Category.assoc</a>, \u2190 <a>Category.assoc</a>, <a>Category.assoc</a>]", "slice_lhs 2 3 => rw [\u2190 <a>Category.assoc</a>, \u2190 <a>Category.assoc</a>, \u2190 <a>Category.assoc</a>]"], "predictions1": ["coherence", "slice_lhs 3 4 => rw [\u2190 <c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).inv = g.inv \u226b f.inv</c>]", "slice_lhs 3 4 => rw [\u2190 <c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).inv = g.inv \u226b f.hom</c>]", "slice_lhs 2 3 => rw [\u2190 <c> {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    (f \u2297 g) \u2297 f \u226b g = f \u226b h \u2297 g</c>]", "slice_lhs 2 3 => rw [\u2190 <c> {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    (f \u2297 g) \u226b f = (f \u2297 g) \u2297 f \u226b g</c>]", "slice_lhs 3 4 => rw [\u2190 <c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).inv = g.inv \u226b f.inv</c> (\u03bb_ (\ud835\udfd9_ C)).<a>hom</a>]", "slice_lhs 3 4 => rw [\u2190 <c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).inv = g.inv \u226b f.inv</c> (\u03bb_ (\ud835\udfd9_ C)).<a>inv</a>]", "slice_lhs 2 3 => rw [\u2190 <c> {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    (f \u2297 g) \u2297 f \u226b g = f \u226b h \u2194 g = h</c> (\u03bb_ (\ud835\udfd9_ C)).<a>hom</a>]"], "predictions2": ["slice_lhs 1 2 => rw [\u2190 <c> (X Y : C) {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).inv = g.inv \u226b f.hom</c>]", "slice_lhs 1 2 => rw [\u2190 <c> (X Y : C) {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).hom = g.hom \u226b f.hom</c>]", "slice_lhs 3 4 => rw [\u2190 <c> (X Y : C) {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).inv = g.inv \u226b f.hom</c>]", "slice_lhs 3 4 => rw [\u2190 <c> (X Y : C) {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).hom = g.hom \u226b f.hom</c>]", "slice_lhs 1 2 => rw [\u2190 <c> (X Y : C) {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).inv = g.inv \u226b f.inv</c>]", "slice_lhs 3 4 => rw [\u2190 <c> (X Y : C) {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).inv = g.inv \u226b f.inv</c>]", "slice_lhs 3 4 => rw [\u2190 <c> (X Y : C) {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u2297 g) \u226b f = (g \u2297 f) \u226b g</c>]", "slice_lhs 1 2 => rw [\u2190 <c> (X Y : C) {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u2297 g) \u226b f = (g \u2297 f) \u226b g</c>]"]}, {"state_before": "F : Type u_1\ninst\u271d\u2078 : Field F\nE : Type u_2\ninst\u271d\u2077 : Field E\ninst\u271d\u2076 : Algebra F E\np : F[X]\nhFE : FiniteDimensional F E\nsp : Polynomial.IsSplittingField F E p\nhp : Polynomial.Separable p\nK : Type u_3\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : Algebra F K\ninst\u271d\u00b3 : Algebra K E\ninst\u271d\u00b2 : IsScalarTower F K E\nx : E\nhx : x \u2208 Polynomial.aroots p E\ninst\u271d\u00b9 : Fintype (K \u2192\u2090[F] E)\ninst\u271d : Fintype (\u21a5(IntermediateField.restrictScalars F K\u27eex\u27ef) \u2192\u2090[F] E)\nh : IsIntegral K x\nh1 : p \u2260 0\n\u22a2 Fintype.card (\u21a5(IntermediateField.restrictScalars F K\u27eex\u27ef) \u2192\u2090[F] E) = Fintype.card (K \u2192\u2090[F] E) * finrank K \u21a5K\u27eex\u27ef", "expanded_tactic": "have h2 : <c> (x : B) : A[X]</c> K x \u2223 p.map (<c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R \u2192+* A</c> F K) := by\n    apply <c> {p : A[X]} (hp : Polynomial.aeval x p = 0) : minpoly A x \u2223 p</c>\n    rw [<c> (p : R[X]) : aeval x p = eval\u2082 (algebraMap R A) x p</c>, <c> [Semiring T] (g : S \u2192+* T) (x : T) : (p.map f).eval\u2082 g x = p.eval\u2082 (g.comp f) x</c>, \u2190 <c> (x : S) : (p.map f).eval x = p.eval\u2082 f x</c>, \u2190\n      <c> : algebraMap R A = (algebraMap S A).comp (algebraMap R S)</c>]\n    exact (<c> (hp : p \u2260 0) : a \u2208 p.roots \u2194 IsRoot p a</c> (<c> [Semiring S] [Nontrivial S] {f : R \u2192+* S} (hp : p \u2260 0) : p.map f \u2260 0</c> h1)).<a>mp</a> hx", "predictions0": ["have h2 : p \u2260 0 := finrank_pos_iff.mpr h1", "have h2 : p \u2260 0 := finrank_ne_zero_iff.mpr h1", "have h2 : p \u2260 0 := finrank_pos_iff.mpr hp", "have h2 : p \u2260 0 := finrank_ne_zero_iff.mpr hp", "have h2 : p \u2260 0 := finrank_ne_zero_iff.mpr hp.ne_zero", "haveI : <c> (\u03b1 : Type*) where\n  \n  val : Multiset \u03b1\n  \n  nodup : Nodup val</c> \u03b1 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "haveI : <c> (\u03b1 : Type*) where\n  \n  val : Multiset \u03b1\n  \n  nodup : Nodup val</c> K x := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "haveI : <c> (\u03b1 : Type*) where\n  \n  val : Multiset \u03b1\n  \n  nodup : Nodup val</c> (K \u2192\u2090[F] E) := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>"], "predictions1": ["haveI : <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : Prop where\n  algebraMap_injective' : Function.Injective (algebraMap R A)</c> F K\u27eex\u27ef := hp", "haveI : <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : Prop where\n  algebraMap_injective' : Function.Injective (algebraMap R A)</c> F K\u27eex\u27ef E := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "haveI : <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : Prop where\n  algebraMap_injective' : Function.Injective (algebraMap R A)</c> F K\u27eex\u27ef E := <c> {\u03b1 : Sort u} [i : \u03b1] : \u03b1</c>", "haveI : <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : Prop where\n  algebraMap_injective' : Function.Injective (algebraMap R A)</c> F K\u27eex\u27ef E := <c> [FiniteDimensional K E] [FiniteDimensional K E]\n    (hp : Polynomial.aroots p E) (hp' : Polynomial.aroots p E \u2260 0) :\n    Fintype.card (K \u2192\u2090[F] E) = Fintype.card (K \u2192\u2090[F] E)</c> h h1", "haveI : <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : Prop where\n  algebraMap_injective' : Function.Injective (algebraMap R A)</c> F K\u27eex\u27ef E := <c> [FiniteDimensional K E] [FiniteDimensional K E]\n    (hp : Polynomial.aroots p E) (hp' : Polynomial.aroots p E \u2260 0) :\n    Fintype.card (K \u2192\u2090[F] E) = Fintype.card (K \u2192\u2090[F] E)</c> h hp", "haveI : <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : Prop where\n  algebraMap_injective' : Function.Injective (algebraMap R A)</c> F K\u27eex\u27ef E := <c> [FiniteDimensional K E] [FiniteDimensional K E]\n    [FiniteDimensional K E] [FiniteDimensional K E] (hp : Polynomial.Separable p) :\n    Fintype.card (K \u2192\u2090[F] E) = Fintype.card (K \u2192\u2090[F] E)</c> h", "haveI : <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : Prop where\n  algebraMap_injective' : Function.Injective (algebraMap R A)</c> F K\u27eex\u27ef E := <c> [FiniteDimensional K E] [FiniteDimensional K E]\n    (hp : Polynomial.aroots p E) (hp' : Polynomial.aroots p E \u2260 0) :\n    Fintype.card (F \u2192\u2090[K] E) = Fintype.card (F \u2192\u2090[K] E)</c> h h1", "haveI : <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : Prop where\n  algebraMap_injective' : Function.Injective (algebraMap R A)</c> F K\u27eex\u27ef E := <c> [FiniteDimensional K E] [FiniteDimensional K E]\n    (hp : Polynomial.aroots p E) (hp' : Polynomial.aroots p E \u2260 0) :\n    Fintype.card (F \u2192\u2090[K] E) = Fintype.card (F \u2192\u2090[K] E)</c> h hp"], "predictions2": ["by_cases h2 : p = 0", "by_cases h1' : p = 0", "by_cases h12 : p = 0", "by_cases h1' : p = 1", "rw [\u2190 <c> [Fintype \u03b1] : (Finset.univ : Finset \u03b1).card = Fintype.card \u03b1</c>]", "by_cases h2 : p \u2208 <c> (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R \u2192+* A</c> F K\u27eex\u27ef E \u2192\u2090[F] E", "by_cases h2 : p \u2208 <c> (K : Type*) [Field K] [AddCommGroup K] [Module K L] : R[X]</c> F K\u27eex\u27ef E", "by_cases h2 : p \u2208 <c> (K : Type*) [Field K] : Prop where\n  \n  exists_pair_ne : \u2203 x y : K, x \u2260 y</c> K x"]}, {"state_before": "C : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nJ : GrothendieckTopology C\nA : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} A\nD : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} D\ninst\u271d : HasWeakSheafify J D\nP Q : C\u1d52\u1d56 \u2964 D\n\u03b7 : P \u27f6 Q\nhQ : Presheaf.IsSheaf J Q\n\u03b3 : sheafify J P \u27f6 Q\n\u22a2 toSheafify J P \u226b \u03b3 = \u03b7 \u2192 \u03b3 = sheafifyLift J \u03b7 hQ", "expanded_tactic": "intro h", "predictions0": ["intro h", "intro h\u03b7", "rw [<c> {X Y Z : C\u1d52\u1d56 \u2964 D} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    toSheafify J P \u226b \u03b3 = sheafifyLift J \u03b7 hQ</c>]", "rw [<c> {X Y Z : C\u1d52\u1d56 \u2964 D} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    toSheafify J P \u226b \u03b3 = sheafifyLift J \u03b7 hQ \u03b3 hQ]", "rw [<c> {X Y Z : C\u1d52\u1d56 \u2964 D} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    toSheafify J P \u226b \u03b3 = sheafifyLift J \u03b7 hQ \u03b7 hQ</c>]", "rw [<c> {X Y Z : C\u1d52\u1d56 \u2964 D} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    toSheafify J P \u226b \u03b3 = sheafifyLift J \u03b7 hQ \u03b3 hQ \u03b3 hQ]", "rw [<c> {X Y Z : C\u1d52\u1d56 \u2964 D} {f : X \u27f6 Y} {g : Y \u27f6 Z} {g : Y \u27f6 Z} :\n    toSheafify J P \u226b \u03b3 = sheafifyLift J \u03b7 hQ</c>]", "rw [<c> {X Y Z : C\u1d52\u1d56 \u2964 D} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    toSheafify J P \u226b \u03b3 = sheafifyLift J \u03b7 hQ \u03b7 hQ \u03b3 hQ]"], "predictions1": ["intro h", "intro h\u03b3", "rw [<c> {P Q : C\u1d52\u1d56 \u2964 D} (\u03b7 : P \u27f6 Q) (\u03b3 : Presheaf.IsSheaf J Q) :\n    toSheafify J P \u226b \u03b3 = sheafifyLift J \u03b7 hQ</c>]", "rw [<c> {P Q : C\u1d52\u1d56 \u2964 D} (\u03b7 : P \u27f6 Q) (\u03b3 : Presheaf.IsSheaf J Q) :\n    toSheafify J P \u226b \u03b3 = toSheafify J \u03b7 hQ</c>]", "rw [<c> {P Q : C\u1d52\u1d56 \u2964 D} (\u03b7 : P \u27f6 Q) (\u03b3 : Presheaf.IsSheaf J Q) :\n    toSheafify J P \u226b \u03b3 = sheafifyLift J \u03b7 hQ \u03b3 hQ</c>]", "rw [<c> {P Q : C\u1d52\u1d56 \u2964 D} (\u03b7 : P \u27f6 Q) (\u03b3 : Presheaf.IsSheaf J Q)\n    (\u03b3' : Presheaf.IsSheaf J Q) (\u03b3 : Presheaf.IsSheaf J Q) :\n    toSheafify J P \u226b \u03b3 = sheafifyLift J \u03b7 hQ \u03b7 hQ</c>]", "rw [<c> {P Q : C\u1d52\u1d56 \u2964 D} (\u03b7 : P \u27f6 Q) (\u03b3 : Presheaf.IsSheaf J Q)\n    (\u03b3' : Presheaf.IsSheaf J Q) (\u03b3 : Presheaf.IsSheaf J Q) :\n    toSheafify J P \u226b \u03b3 = sheafifyLift J \u03b7 hQ \u03b3 hQ</c>]", "induction' \u03b3 using <c> {P Q : C\u1d52\u1d56 \u2964 D} (\u03b7 : P \u27f6 Q) (hQ : Presheaf.IsSheaf J Q)\n    (hQ : Presheaf.IsSheaf J Q) (hQ : Presheaf.IsSheaf J Q) (\u03b3 : Presheaf.IsSheaf J Q) : P \u27f6 Q</c> with \u03b3' h\u03b3'"], "predictions2": ["intro h", "intro h\u03b3", "dsimp [<c> {P Q : C\u1d52\u1d56 \u2964 D} (\u03b7 : P \u27f6 Q) (\u03b3' : J.Presheaf.IsSheaf J) :\n    J.sheafify J P \u27f6 J.sheafify J</c>]", "dsimp [<c> {P Q : C\u1d52\u1d56 \u2964 D} (\u03b7 : P \u27f6 Q) (\u03b3' : J.Presheaf.IsSheaf J)\n    (\u03b3 : J.Presheaf.IsSheaf J) : J.sheafify J P \u27f6 J</c>]", "dsimp [<c> {P Q : C\u1d52\u1d56 \u2964 D} (\u03b7 : P \u27f6 Q) (\u03b3' : J.Presheaf.IsSheaf J)\n    (\u03b3 : J.Presheaf.IsSheaf J) : J.Presheaf J</c>]", "dsimp [<c> {P Q : C\u1d52\u1d56 \u2964 D} (\u03b7 : P \u27f6 Q) (\u03b3' : J.Presheaf.IsSheaf J)\n    (\u03b3 : J.Presheaf.IsSheaf J) : J.toSheafify P \u27f6 J</c>]", "dsimp [<c> {P Q : C\u1d52\u1d56 \u2964 D} (\u03b7 : P \u27f6 Q) (\u03b3' : J.Presheaf.IsSheaf J)\n    (\u03b3 : J.Presheaf.IsSheaf J) : J.toSheafify J P \u27f6 J</c>]", "dsimp [<c> {P Q : C\u1d52\u1d56 \u2964 D} (\u03b7 : P \u27f6 Q) (\u03b3' : J.Presheaf.IsSheaf J)\n    (\u03b3 : J.Presheaf.IsSheaf J) : J.toSheafify J P \u27f6 Q</c>]"]}, {"state_before": "C : Type u_1\ninst\u271d\u2078 : Category.{u_4, u_1} C\ninst\u271d\u2077 : Preadditive C\ninst\u271d\u2076 : MonoidalCategory C\ninst\u271d\u2075 : MonoidalPreadditive C\nD : Type u_2\ninst\u271d\u2074 : Category.{u_3, u_2} D\ninst\u271d\u00b3 : Preadditive D\ninst\u271d\u00b2 : MonoidalCategory D\nF : MonoidalFunctor D C\ninst\u271d\u00b9 : Faithful F.toFunctor\ninst\u271d : Functor.Additive F.toFunctor\nX\u271d Y\u271d Z\u271d : D\n\u22a2 0 \u25b7 X\u271d = 0", "expanded_tactic": "apply F.toFunctor.map_injective", "predictions0": ["apply F.toFunctor.map_injective", "apply F.toFunctor.map_whiskerLeft", "apply F.toFunctor.map_whiskerRight", "unfold <c> (X : C) : C</c>", "unfold <c> (X : C) : Preadditive X</c>", "ext", "rw [F.toFunctor.map_whiskerLeft, F.toFunctor.map_zero]", "rw [F.toFunctor.map_whiskerLeft, F.toFunctor.map_whiskerRight]"], "predictions1": ["apply F.toFunctor.map_injective", "apply F.toFunctor.map_whiskerLeft", "apply F.toFunctor.map_whiskerRight", "apply F.toFunctor.map_whisker_exchange", "apply F.toFunctor.map_whisker_ext", "apply F.toFunctor.map_whisker", "apply F.toFunctor.map_ext", "apply F.map_whiskerLeft"], "predictions2": ["apply F.toFunctor.map_injective", "apply <c> (X Y : C) : (0 : X \u27f6 Y) \u25b7 Y = 0</c>", "apply <c> [HasZeroMorphisms C] {X Y : C} {f : X \u27f6 Y} {Z : C} :\n    f \u226b (0 : Y \u27f6 Z) = (0 : X \u27f6 Z)</c>", "apply <c> (X Y : C) {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).f = g.f \u226b h.inv</c>", "apply <c> {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) [Epi f] (g : Y \u27f6 Z) : f \u226b g = f</c>", "apply <c> {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) [HasPullback f g] : pullback f g \u226b pullback f g = pullback.snd \u226b g</c>", "apply <c> {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) [HasPullback f g] :\n    (0 : X \u27f6 Y) \u226b f = (0 : X \u27f6 Z)</c>", "apply <c> {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) (w : f \u226b g = f \u226b h) : f \u226b g = f</c>"]}, {"state_before": "case refine_1\nm : Type u_1 \u2192 Type u_2\n\u03b2 : Type u_1\ninst\u271d : Monad m\nr : Range\ninit : \u03b2\nf : Nat \u2192 \u03b2 \u2192 m (ForInStep \u03b2)\nfuel : Nat\n\u22a2 \u2200 (i : Nat) (hl : r.start \u2264 i) (b : \u03b2),\n    forIn'.loop r.start r.stop r.step (fun x x_1 => f x) fuel i hl b = forIn.loop f fuel i r.stop r.step b", "expanded_tactic": "induction fuel <;> intro i hl b <;>\n      unfold <a>forIn.loop</a> <a>forIn'.loop</a> <;> simp [*]", "predictions0": ["exact fuel", "exact fuel.init", "induction r <;> simp [*]", "induction fuel <;> simp [*]", "induction r using <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "induction r <;> simp [*, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>]", "induction fuel <;> simp [*, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>]", "induction r <;> simp [*, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>]"], "predictions1": ["exact fuel", "exact fuel.init", "induction fuel <;> intro i hl b", "induction fuel with\n  | <a>zero</a> => simp [<c> (f : Nat \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) (init : \u03b2) (f : Nat \u2192 \u03b2 \u2192 m (ForInStep \u03b2))\n    (init : \u03b2) : m (ForInStep \u03b2)</c>]", "induction fuel with\n  | <a>zero</a> => simp [<c> (f : Nat \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) (init : \u03b2) (f : Nat \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) :\n    m (ForInStep \u03b2) \u2192 m (ForInStep \u03b2)</c>]\n    | <a>succ</a> fuel ih =>\n    intro i hl b\n    rw [<c> {\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b4 : Sort w} (f : \u03b2 \u2192 \u03b4) (g : \u03b1 \u2192 \u03b2) : \u03b1 \u2192 \u03b4</c>, <c> {\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b4 : Sort w} (f : \u03b2 \u2192 \u03b4) (g : \u03b1 \u2192 \u03b2) : \u03b1 \u2192 \u03b4</c>, ih]", "induction fuel with\n  | <a>zero</a> => simp [<c> (f : Nat \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) (init : \u03b2) (f : Nat \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) :\n    m (ForInStep \u03b2) \u2192 m (ForInStep \u03b2)</c>]\n    | <a>succ</a> fuel ih =>\n    intro i hl b\n    rw [<c> {\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b4 : Sort w} (f : \u03b2 \u2192 \u03b4) (g : \u03b1 \u2192 \u03b2) : \u03b1 \u2192 \u03b4</c>, <c> {\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b4 : Sort w} (f : \u03b2 \u2192 \u03b4) (g : \u03b1 \u2192 \u03b2) : \u03b1 \u2192 \u03b4</c>]", "induction fuel with\n  | <a>zero</a> => simp [<c> (f : Nat \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) (init : \u03b2) (f : Nat \u2192 \u03b2 \u2192 m (ForInStep \u03b2))\n    (init : \u03b2) : m (ForInStep \u03b2) \u2192 m (ForInStep \u03b2)</c>]\n    | <a>succ</a> fuel ih =>\n    intro i hl b\n    rw [<c> {\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b4 : Sort w} (f : \u03b2 \u2192 \u03b4) (g : \u03b1 \u2192 \u03b2) : \u03b1 \u2192 \u03b4</c>, <c> {\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b4 : Sort w} (f : \u03b2 \u2192 \u03b4) (g : \u03b1 \u2192 \u03b2) : \u03b1 \u2192 \u03b4</c>, ih]", "induction fuel with\n  | <a>zero</a> => simp [<c> (f : Nat \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) (init : \u03b2) (f : Nat \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) :\n    m (ForInStep \u03b2) \u2192 m (ForInStep \u03b2)</c>]\n    | <a>succ</a> fuel ih =>\n    intro i hl b\n    rw [<c> {\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b4 : Sort w} (f : \u03b2 \u2192 \u03b4) (g : \u03b1 \u2192 \u03b2) : \u03b1 \u2192 \u03b4</c>, <c> {\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b4 : Sort w} (f : \u03b2 \u2192 \u03b4) (g : \u03b1 \u2192 \u03b2) : \u03b1 \u2192 \u03b4</c>, <c> {\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b4 : Sort w} (f : \u03b2 \u2192 \u03b4) (g : \u03b1 \u2192 \u03b2) : \u03b1 \u2192 \u03b4</c>, ih]"], "predictions2": ["exact fuel", "induction fuel <;> simp [*, <c> {n m : Nat} (h : n \u2264 m) : n + (m - n) = m</c>]", "induction r generalizing fuel with\n  | <a>zero</a> => simp [*, <c> {\u03b1 : Sort u} (a : \u03b1) : \u03b1</c>]", "induction r generalizing fuel with\n  | <a>zero</a> => rfl\n  | <a>succ</a> fuel ih => exact fuel", "induction r generalizing fuel with\n  | <a>zero</a> => rfl\n  | <a>succ</a> fuel ih => exact fuel\n  | <a>succ</a> fuel => cases fuel <;> simp [*]", "induction r generalizing fuel with\n  | <a>zero</a> => rfl\n  | <a>succ</a> => simp [<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>]\n  | <a>succ</a> => rfl", "induction r generalizing fuel with\n  | <a>zero</a> => rfl\n  | <a>succ</a> fuel ih => simp [<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>]\n  | <a>succ</a> f ih => exact fuel", "induction r generalizing fuel with\n  | <a>zero</a> => rfl\n  | <a>succ</a> fuel ih => simp [<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>]\n  | <a>succ</a> f ih => exact f"]}, {"state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nm : \u03b1 \u2192 \u03b2\nf : Filter \u03b1\ns : Set \u03b2\n\u22a2 s \u2208 kernMap m f \u2194 \u2203 t, t\u1d9c \u2208 f \u2227 m '' t = s\u1d9c", "expanded_tactic": "rw [<c> {s : Set \u03b2} : s \u2208 kernMap m f \u2194 \u2203 t \u2208 f, kernImage m t = s</c>, compl_surjective.exists]", "predictions0": ["simp only [<c> {s : Set \u03b1} {f : Filter \u03b1} : s \u2208 kernMap m f \u2194 \u2203 t \u2208 f, t \u2208 f \u2227 m '' t = s\u1d9c</c>, <c> {s : Set \u03b1} : s \u2208 f \u2194 \u2203 t \u2208 f, m '' t = s\u1d9c</c>]", "simp only [<c> {s : Set \u03b1} {f : Filter \u03b1} : s \u2208 kernMap m f \u2194 \u2203 t \u2208 f, t \u2208 f \u2227 m '' t = s\u1d9c</c>, <c> {s : Set \u03b1} : s \u2208 f \u2194 \u2203 t, t \u2208 f \u2227 m '' t = s\u1d9c</c>]", "simp only [<c> {s : Set \u03b1} {f : Filter \u03b1} : s \u2208 kernMap m f \u2194 \u2203 t \u2208 f, t \u2208 f \u2227 m '' t = s\u1d9c</c>, <c> {s : Set \u03b1} : s \u2208 f \u2194 \u2203 t, t\u1d9c \u2208 f \u2227 m '' t = s\u1d9c</c>]", "simp only [<c> {f : Filter \u03b1} {s : Set \u03b2} :\ns \u2208 kernMap m f \u2194 \u2203 t \u2208 f, t \u2208 f \u2227 m '' t = s\u1d9c</c>, <c> {s : Set \u03b1} : s \u2208 f \u2194 \u2203 t, t \u2208 f \u2227 m '' t = s\u1d9c</c>]", "simp only [<c> {s : Set \u03b1} {f : Filter \u03b1} : s \u2208 kernMap m f \u2194 \u2203 t \u2208 f, t \u2208 f \u2227 m '' t = s\u1d9c</c>, <c> {s : Set \u03b1} : s \u2208 f \u2194 \u2203 t \u2208 f, t \u2208 f \u2227 m '' t = s\u1d9c</c>]", "simp only [<c> {f : Filter \u03b1} {s : Set \u03b2} :\ns \u2208 kernMap m f \u2194 \u2203 t \u2208 f, t \u2208 f \u2227 m '' t = s\u1d9c</c>, <c> {s : Set \u03b1} : s \u2208 f \u2194 \u2203 t \u2208 f, t \u2208 f \u2227 m '' t = s\u1d9c</c>]", "simp only [<c> {s : Set \u03b1} {f : Filter \u03b1} : s \u2208 kernMap m f \u2194 \u2203 t \u2208 f, t \u2208 f \u2227 m '' t = s\u1d9c</c>, <c> {s : Set \u03b1} : s \u2208 f \u2194 \u2203 t, t\u1d9c \u2208 f \u2227 m '' t = s\u1d9c</c>, <c> {s : Set \u03b1} : s \u2208 f \u2194 \u2203 t, t \u2208 f \u2227 m '' t = s\u1d9c</c>]", "simp only [<c> {s : Set \u03b1} {f : Filter \u03b1} : s \u2208 kernMap m f \u2194 \u2203 t \u2208 f, t \u2208 f \u2227 m '' t = s\u1d9c</c>, <c> {s : Set \u03b1} : s \u2208 f \u2194 \u2203 t \u2208 f, t \u2208 f \u2227 m '' t = s\u1d9c</c>, <c> {s : Set \u03b1} : s \u2208 f \u2194 \u2203 t, t \u2208 f \u2227 m '' t = s\u1d9c</c>]"], "predictions1": ["rw [<c> {s : Set \u03b1} {f : Filter \u03b1} : s \u2208 kernMap m f \u2194 \u2203 t \u2208 f, m '' t = s\u1d9c</c>]", "simp_rw [<c> {s : Set \u03b1} {f : Filter \u03b1} : s \u2208 kernMap m f \u2194 \u2203 t \u2208 f, m '' t = s\u1d9c</c>]", "simp_rw [<c> {s : Set \u03b1} {f : Filter \u03b1} : s \u2208 kernMap m f \u2194 \u2203 t, t\u1d9c \u2208 f \u2227 m '' t = s\u1d9c</c>]", "simp_rw [<c> {s : Set \u03b1} {f : Filter \u03b1} : s \u2208 kernMap m f \u2194 \u2203 t \u2208 f, m '' t = s</c>]", "simp_rw [<c> {s : Set \u03b1} {f : Filter \u03b1} : s \u2208 kernMap m f \u2194 \u2203 t, t\u1d9c \u2208 f \u2227 m '' t = s\u1d9c</c>, <c> {s : Set \u03b1} : s \u2208 kernMap m f \u2194 \u2203 t \u2208 f, m '' t = s\u1d9c</c>]", "simp_rw [<c> {s : Set \u03b1} {f : Filter \u03b1} : s \u2208 kernMap m f \u2194 \u2203 t, t\u1d9c \u2208 f \u2227 m '' t = s\u1d9c</c>, <c> {s : Set \u03b1} : s \u2208 kernMap m f \u2194 \u2203 t \u2208 f, m '' t = s</c>]", "simp_rw [<c> {s : Set \u03b1} {f : Filter \u03b1} : s \u2208 kernMap m f \u2194 \u2203 t, t\u1d9c \u2208 f \u2227 m '' t = s\u1d9c</c>, <c> {s : Set \u03b1} {f : Filter \u03b1} : s \u2208 kernMap m f \u2194 \u2203 t \u2208 f, m '' t = s\u1d9c</c>]", "simp_rw [<c> {s : Set \u03b1} {f : Filter \u03b1} : s \u2208 kernMap m f \u2194 \u2203 t, t\u1d9c \u2208 f \u2227 m '' t = s\u1d9c</c>, <c> {s : Set \u03b1} {f : Filter \u03b1} : s \u2208 f \u2194 \u2203 t, t\u1d9c \u2208 f \u2227 m '' t = s\u1d9c</c>]"], "predictions2": ["simp only [<c> (m : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop</c>, <c> : (\u2203 _h : a, b) \u2194 a \u2227 b</c>]", "simp only [<c> (m : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop</c>, <c> : (\u2203 _h : a, b) \u2194 a \u2227 b</c>, <c> : (\u2203 _h : a, b) \u2194 a \u2227 b</c>]", "simp only [<c> (m : \u03b1 \u2192 \u03b2) (f : Filter \u03b1) (s : Set \u03b2) :\n    s \u2208 kernMap m f \u2194 \u2203 t \u2208 f, m '' t = s\u1d9c \u2227 m '' t = s</c>]", "simp only [<c> (m : \u03b1 \u2192 \u03b2) (f : Filter \u03b1) (s : Set \u03b1) :\n    s \u2208 kernMap m f \u2194 \u2203 t \u2208 f, m '' t = s\u1d9c \u2227 m '' t = s</c>]", "simp only [<c> (m : \u03b1 \u2192 \u03b2) (f : Filter \u03b1) (s : Set \u03b2) :\n    s \u2208 kernMap m f \u2194 \u2203 t \u2208 f, m '' t = s\u1d9c</c>, <c> : (\u2203 _h : a, b) \u2194 a", "simp only [<c> (m : \u03b1 \u2192 \u03b2) (f : Filter \u03b1) (s : Set \u03b1) :\n    s \u2208 kernMap m f \u2194 \u2203 t \u2208 f, m '' t = s\u1d9c</c>, <c> : (\u2203 _h : a, b) \u2194 a", "simp only [<c> (m : \u03b1 \u2192 \u03b2) (f : Filter \u03b1) (s : Set \u03b2) :\n    s \u2208 kernMap m f \u2194 \u2203 t \u2208 f, m '' t = s\u1d9c \u2227 m '' t = s\u1d9c</c>]", "simp only [<c> (m : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop</c>, <c> {s : Set \u03b1} {f : Filter \u03b1} :\n    s \u2208 kernMap m f \u2194 \u2203 t \u2208 f, m '' t = s\u1d9c</c>]"]}, {"state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d : MonoidalCategory C\nM : Mon_ C\nZ : C\nf : Z \u27f6 M.X\n\u22a2 (M.one \u2297 f) \u226b M.mul = (\u03bb_ Z).hom \u226b f", "expanded_tactic": "rw [<a>tensorHom_def'_assoc</a>, M.one_mul, <a>leftUnitor_naturality</a>]", "predictions0": ["simp", "rw [<a>Category.assoc</a>, M.mul_one, <a>Category.assoc</a>]", "rw [<a>Category.assoc</a>, M.mul_one_mul, <a>Category.assoc</a>]", "rw [\u2190 <a>Category.assoc</a>, M.mul_one, <a>Category.assoc</a>]", "rw [\u2190 <a>Category.assoc</a>, M.mul_one_mul, <a>Category.assoc</a>]", "rw [<a>Category.assoc</a>, M.mul_one, <a>Category.assoc</a>, <a>Category.assoc</a>]", "rw [<a>Category.assoc</a>, M.mul_one_mul, <a>Category.assoc</a>, <a>Category.assoc</a>]", "rw [<a>Category.assoc</a>, M.mul_one, <a>Category.assoc</a>, <a>Category.comp_id</a>]"], "predictions1": ["rw [\u2190 <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} : (f \u226b g).hom = g.hom \u226b f.hom</c>, <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} : (f \u226b g).hom = g.hom \u226b f.hom</c>]", "rw [\u2190 <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} : (f \u226b g).hom = g.hom \u226b f.hom</c>, <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} : (f \u226b g).hom = f.hom \u226b g.hom</c>]", "rw [\u2190 <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} : (f \u226b g).hom = g.hom \u226b f.hom</c>, <c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).hom = g.hom \u226b f.hom</c>]", "rw [\u2190 <c> {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n    (\u03bb_ Z).hom \u226b f = (\u03bb_ Z).hom \u226b g</c>, <c> {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n    (\u03bb_ Z).hom \u226b f = (\u03bb_ Z).hom \u226b g</c>]", "rw [\u2190 <c> {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    (\u03bb_ Z).hom \u226b f = (\u03bb_ Z).hom \u226b g</c>, <c> {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n    (\u03bb_ Z).hom \u226b f = (\u03bb_ Z).hom \u226b g</c>]", "rw [\u2190 <c> {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n    (\u03bb_ Z).hom \u226b f = (\u03bb_ Z).hom \u226b g</c>, <c> {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n    (\u03bb_ Z).hom \u226b f = (\u03bb_ Z).hom \u226b f</c>]", "rw [\u2190 <c> {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n    (\u03bb_ Z).hom \u226b f = (\u03bb_ Z).hom \u226b g</c>, <c> {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n    (\u03bb_ Z).hom \u226b f = (\u03bb_ Z).hom \u226b f \u226b g</c>]", "rw [\u2190 <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} : (f \u226b g).hom = g.hom \u226b f.hom</c>, <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} : (f \u226b g).hom = g.hom \u226b f.hom</c>, <a>Category.assoc</a>]"], "predictions2": ["rw [\u2190 <c> (X : C) {Y\u2081 Y\u2082 : C} (f : Y\u2081 \u27f6 Y\u2082) :\n    \ud835\udfd9 X \u2297 f = X \u25c1 f</c>]", "rw [\u2190 <c> (X : C) {Y\u2081 Y\u2082 : C} (f : Y\u2081 \u27f6 Y\u2082) :\n    \ud835\udfd9 X \u2297 f = X \u25c1 f</c>, <a>tensor_comp</a>]", "rw [\u2190 <c> (X : C) {Y\u2081 Y\u2082 : C} (f : Y\u2081 \u27f6 Y\u2082) :\n    \ud835\udfd9 X \u2297 f = X \u25c1 f</c>, <a>tensorHom_def</a>]", "rw [\u2190 <c> (X : C) {Y\u2081 Y\u2082 : C} (f : Y\u2081 \u27f6 Y\u2082) :\n    \ud835\udfd9 X \u2297 f = X \u25c1 f</c>, <c> (X : C) {Y\u2081 Y\u2082 : C} (f : Y\u2081 \u27f6 Y\u2082) :\n    \ud835\udfd9 X \u2297 f =", "rw [\u2190 <c> (X : C) {Y\u2081 Y\u2082 : C} (f : Y\u2081 \u27f6 Y\u2082) :\n    \ud835\udfd9 X \u2297 f = X \u25c1 f</c>, <c> (X : C) {Y\u2081 Y\u2082 : C} (f : Y\u2081 \u27f6 Y\u2082) :\n    \ud835\udfd9 X \u2297 f", "rw [\u2190 <c> (X : C) {Y\u2081 Y\u2082 : C} (f : Y\u2081 \u27f6 Y\u2082) :\n    \ud835\udfd9 X \u2297 f = X \u25c1 f</c>, <c> (X : C) {Y\u2081 Y\u2082 : C} (f : Y\u2081 \u27f6 Y\u2082) :\n    \ud835\udfd9 X \u2297 f = X \u25c1", "rw [\u2190 <c> (X : C) {Y\u2081 Y\u2082 : C} (f : Y\u2081 \u27f6 Y\u2082) :\n    \ud835\udfd9 X \u2297 f = X \u25c1 f</c>, <c> (X : C) {Y\u2081 Y\u2082 : C} (f : Y\u2081 \u27f6 Y\u2082) :\n    \ud835\udfd9 X = f", "rw [\u2190 <c> (X : C) {Y\u2081 Y\u2082 : C} (f : Y\u2081 \u27f6 Y\u2082) :\n    \ud835\udfd9 X \u2297 f = X \u25c1 f</c>, <a>tensor_comp</a>, <a>tensor_comp</a>]"]}, {"state_before": "C : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nJ : GrothendieckTopology C\nA : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} A\nD : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} D\ninst\u271d : HasWeakSheafify J D\nP Q : C\u1d52\u1d56 \u2964 D\n\u03b7 : P \u27f6 Q\nhQ : Presheaf.IsSheaf J Q\n\u03b3 : sheafify J P \u27f6 Q\nh : (sheafificationAdjunction J D).unit.app P \u226b \u03b3 = \u03b7\n\u03b3' : (presheafToSheaf J D).obj P \u27f6 { val := Q, cond := hQ } := { val := \u03b3 }\n\u22a2 \u03b3 = (((sheafificationAdjunction J D).homEquiv P { val := Q, cond := hQ }).symm \u03b7).val", "expanded_tactic": "change \u03b3'.val = _", "predictions0": ["change \u03b3'.val = _", "let \u03b3'' : \u03b3' \u27f6 \u03b3' := \u03b3'", "let \u03b3'' : \u03b3' \u27f6 \u03b3' := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "rw [\u2190 h, <c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : f = g \u2194 f = h</c>]", "rw [\u2190 h, <c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} {g : Y \u27f6 Z} : g = f \u2194 g = h</c>]", "let \u03b3'' : \u03b3' \u27f6 \u03b3' := <c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> \u03b3'", "let \u03b3'' : \u03b3' \u27f6 \u03b3' := <c> {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>.1 h", "rw [\u2190 h, <c> {X Y Z : C\u1d52\u1d56 \u2964 D} {f : X \u27f6 Y} {g : Y \u27f6 Z} :\n    (f \u226b g).homEquiv f = g.homEquiv f g</c>]"], "predictions1": ["change \u03b3'.val = _", "change \u03b3'.val = \u03b3'.val", "exact <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "exact <c> {\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {f g : (x : \u03b1) \u2192 \u03b2 x}\n    (h : \u2200 x, f x = g x) : f = g</c> h", "exact <c> {\u03b1 : Sort u} {a b : \u03b1} (h : Eq a b) : Eq b a</c> h", "exact <c> {\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {f g : (x : \u03b1) \u2192 \u03b2 x}\n    (h : \u2200 x, f x = g x) : f = g</c> h \u03b3'", "exact <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> h", "exact <c> {\u03b1 : Sort u} {a b : \u03b1} (h : Eq a b) : Eq b a</c> h \u03b3'"], "predictions2": ["exact <c></c> _ h", "refine' <c>]\ntheorem </c> _", "exact <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "exact <c></c> _ h \u03b3'", "exact <c> {\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {f g : (x : \u03b1) \u2192 \u03b2 x}\n    (h : \u2200 x, f x = g x) : f = g</c> h", "exact <c> {\u03b1 : Sort u} {a b c : \u03b1} (h\u2081 : Eq a b) (h\u2082 : Eq b c) : Eq a c</c> h \u03b3'", "exact <c> {\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {f g : (x : \u03b1) \u2192 \u03b2 x}\n    (h : \u2200 x, f x = g x) : f = g</c> fun x => h", "exact <c> {\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {f g : (x : \u03b1) \u2192 \u03b2 x}\n    (h : \u2200 x, f x = g x) : f = g</c> h \u03b3'"]}, {"state_before": "C : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Abelian C\nX Y : C\nf : X \u27f6 Y\nA B : C\u1d52\u1d56\ng : A \u27f6 B\n\u22a2 (imageUnopOp g).inv \u226b (factorThruImage g.unop).op = image.\u03b9 g", "expanded_tactic": "rw [<c> (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : \u03b1.inv \u226b f = g \u2194 f = \u03b1.hom \u226b g</c>, <c> :\n    (imageUnopOp g).hom \u226b image.\u03b9 g = (factorThruImage g.unop).op</c>]", "predictions0": ["ext", "rw [\u2190 <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {g : Y \u27f6 Z} :\n    (imageUnopOp g).inv \u226b (factorThruImage g.unop).op = image.\u03b9 g</c>]", "rw [\u2190 <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {g : Y \u27f6 Z} :\n    (imageUnopOp g).inv \u226b (factorThruImage g.unop).op = image.\u03b9 g</c> g.unop]", "rw [\u2190 <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {g : Y \u27f6 Z} :\n    (imageUnopOp g).inv \u226b (factorThruImage g.unop).op = image.\u03b9 g</c>, <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {g : Y \u27f6 Z} :\n    (image.\u03b9 g).op = image.\u03b9 g.op</c>]", "rw [\u2190 <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {g : Y \u27f6 Z} :\n    (imageUnopOp g).inv \u226b (factorThruImage g.unop).op = image.\u03b9 g</c>, <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {g : Y \u27f6 Z} :\n    (image.\u03b9 g).inv \u226b (image.\u03b9 g).op = image.\u03b9 g</c>]", "rw [\u2190 <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {g : Y \u27f6 Z} :\n    (imageUnopOp g).inv \u226b (factorThruImage g.unop).op = image.\u03b9 g</c>, <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {g : Y \u27f6 Z} :\n    (imageUnopOp g).inv \u226b (image.\u03b9 g).op = image.\u03b9 g</c>]", "rw [\u2190 <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {g : Y \u27f6 Z} :\n    (imageUnopOp g).inv \u226b (factorThruImage g.unop).op = image.\u03b9 g</c>, <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {g : Y \u27f6 Z} :\n    (image.\u03b9 g).op = image.\u03b9 g.op</c>, <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {g : Y \u27f6 Z} :\n    (image.\u03b9 g).op = image.\u03b9 g.op</c>]", "rw [\u2190 <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {g : Y \u27f6 Z} :\n    (imageUnopOp g).inv \u226b (factorThruImage g.unop).op = image.\u03b9 g</c>, <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {g : Y \u27f6 Z} :\n    (image.\u03b9 g).inv \u226b (image.\u03b9 g).op = image.\u03b9 g</c>, <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {g : Y \u27f6 Z} :\n    (image.\u03b9 g).op = image.\u03b9 g</c>]"], "predictions1": ["rw [<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>]", "rw [\u2190 <c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> (<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> g.unop)]", "rw [\u2190 <c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> (<c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> g.unop)]", "rw [\u2190 <c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> (<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> g.unop).<a>op</a>]", "rw [\u2190 <c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> (<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> g.unop.unop)]", "rw [\u2190 <c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> (<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> g.unop), <c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>]", "rw [\u2190 <c> (f : X \u27f6 Y) [I : IsIso f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> (<c> (f : X \u27f6 Y) [I : IsIso f] : image f \u27f6 Y</c> g.unop)]", "rw [\u2190 <c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> (<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> g.unop),\n    <c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>]"], "predictions2": ["rw [<c> (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : \u03b1.inv \u226b f = g \u2194 f = \u03b1.hom \u226b g</c>]", "rw [\u2190 <c> (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : g = \u03b1.inv \u226b f \u2194 \u03b1.hom \u226b g = f</c>]", "rw [\u2190 <c> (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : g = \u03b1.inv \u226b f \u2194 \u03b1.hom \u226b g = f</c>, <a>image.fac</a>]", "rw [\u2190 <c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> (<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</", "rw [\u2190 <c> (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : \u03b1.inv \u226b f = g \u2194 f = \u03b1.hom \u226b g</c>, <c> (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : \u03b1.inv \u226b f = ", "rw [\u2190 <c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> (<c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>", "rw [\u2190 <c> (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : g = \u03b1.inv \u226b f \u2194 \u03b1.hom \u226b g = f</c>, <c> (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : \u03b1.inv \u226b f = ", "rw [\u2190 <c> (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : g = \u03b1.inv \u226b f \u2194 \u03b1.hom \u226b g = f</c>, <c> (f : X \u27f6 Y) [I : IsIso f] : image f \u226b image f ="]}, {"state_before": "case neg.intro.intro.intro.refine'_1.refine'_2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : IsDomain R\ninst\u271d\u2075 : IsPrincipalIdealRing R\nM\u271d : Type u_3\ninst\u271d\u2074 : AddCommGroup M\u271d\ninst\u271d\u00b3 : Module R M\u271d\nb : \u03b9 \u2192 M\u271d\ninst\u271d\u00b2 : Finite \u03b9\nO : Type u_4\ninst\u271d\u00b9 : AddCommGroup O\ninst\u271d : Module R O\nM N : Submodule R O\nb'M : Basis \u03b9 R \u21a5M\nN_bot : N \u2260 \u22a5\nN_le_M : N \u2264 M\nthis : \u2203 \u03d5, \u2200 (\u03c8 : \u21a5M \u2192\u2097[R] R), \u00acLinearMap.submoduleImage \u03d5 N < LinearMap.submoduleImage \u03c8 N\n\u03d5 : \u21a5M \u2192\u2097[R] R := Exists.choose this\n\u03d5_max : \u2200 (\u03c8 : \u21a5M \u2192\u2097[R] R), \u00acLinearMap.submoduleImage (Exists.choose this) N < LinearMap.submoduleImage \u03c8 N\na : R := generator (LinearMap.submoduleImage \u03d5 N)\na_mem : a \u2208 LinearMap.submoduleImage \u03d5 N\na_zero : \u00aca = 0\ny : O\nyN : y \u2208 N\n\u03d5y_eq : \u03d5 { val := y, property := \u22ef } = a\n_\u03d5y_ne_zero : \u03d5 { val := y, property := \u22ef } \u2260 0\nc : \u03b9 \u2192 R\nhc : \u2200 (i : \u03b9), (Basis.coord b'M i) { val := y, property := \u22ef } = a * c i\nval\u271d : Fintype \u03b9\ny' : O := \u2211 i : \u03b9, c i \u2022 \u2191(b'M i)\ny'M : y' \u2208 M\nmk_y' : { val := y', property := y'M } = \u2211 i : \u03b9, c i \u2022 b'M i\na_smul_y' : a \u2022 y' = y\n\u03d5y'_eq : \u03d5 { val := y', property := y'M } = 1\n\u03d5y'_ne_zero : \u03d5 { val := y', property := y'M } \u2260 0\nM' : Submodule R O := map (Submodule.subtype M) (LinearMap.ker \u03d5)\nN' : Submodule R O := map (Submodule.subtype N) (LinearMap.ker (\u03d5 \u2218\u2097 inclusion N_le_M))\nM'_le_M : M' \u2264 M\nN'_le_M' : N' \u2264 M'\nN'_le_N : N' \u2264 N\ny'_ortho_M' : \u2200 (c : R), \u2200 z \u2208 M', c \u2022 y' + z = 0 \u2192 c = 0\nay'_ortho_N' : \u2200 (c : R), \u2200 z \u2208 N', c \u2022 a \u2022 y' + z = 0 \u2192 c = 0\nn' : \u2115\nbN' : Basis (Fin n') R \u21a5N'\nz : O\nzN : z \u2208 N\n\u22a2 \u2203 c, z + c \u2022 y \u2208 N'", "expanded_tactic": "obtain \u27e8b, hb\u27e9 : _ \u2223 \u03d5 \u27e8z, N_le_M zN\u27e9 := <c> {N O : Submodule R M} (hNO : N \u2264 O) (\u03d5 : O \u2192\u2097[R] R)\n    [(\u03d5.submoduleImage N).IsPrincipal] {x : M} (hx : x \u2208 N) :\n    generator (\u03d5.submoduleImage N) \u2223 \u03d5 \u27e8x, hNO hx\u27e9</c> N_le_M \u03d5 zN", "predictions0": ["refine' \u27e8-z, _\u27e9", "refine' \u27e8-c, _\u27e9", "refine' \u27e8-1, _\u27e9", "obtain \u27e8c, rfl\u27e9 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "obtain \u27e8c, rfl\u27e9 := <c> {\u03b1 : Sort u} {a b : \u03b1} : Eq a a</c>", "obtain \u27e8c, rfl\u27e9 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> zN", "exact \u27e8-z, by simp only [N', <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>]\u27e9", "obtain \u27e8c, rfl\u27e9 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> (N'_le_M zN)"], "predictions1": ["refine' \u27e8-a, _, _\u27e9", "refine' \u27e8-\u03d5 \u27e8z, N_le_M zN\u27e9, _\u27e9", "refine' \u27e8-\u03d5 \u27e8y, N_le_M zN\u27e9, _\u27e9", "refine' \u27e8-\u03d5 \u27e8z, N_le_M zN\u27e9, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9", "refine' \u27e8-\u03d5 \u27e8y, N_le_M zN\u27e9, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9", "refine' \u27e8-\u03d5 \u27e8y, N_le_M zN\u27e9, _, _\u27e9", "refine' \u27e8-\u03d5 \u27e8z, N_le_M zN\u27e9, _, _\u27e9", "exact \u27e8-\u03d5 \u27e8y, N_le_M zN\u27e9, bN'.mem_map_of_mem zN\u27e9"], "predictions2": ["exact \u27e8-y, N'_le_M zN\u27e9", "refine' \u27e8-c, _\u27e9", "refine' \u27e8-\u03d5 \u27e8y, zN\u27e9, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9", "refine' \u27e8-\u03d5 \u27e8y, N_le_M zN\u27e9, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9", "refine' \u27e8-\u03d5 \u27e8y, N_le_M zN\u27e9, _\u27e9", "refine' \u27e8-\u03d5 \u27e8y, N_le_M yN\u27e9, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9", "refine' \u27e8-\u03d5 \u27e8y, N_le_M yN\u27e9, _, _\u27e9", "refine' \u27e8-\u03d5 \u27e8y, N_le_M zN\u27e9, _, _\u27e9"]}, {"state_before": "case intro\nC : Type u\ninst\u271d\u2076 : Category.{v, u} C\nD : Type u_1\ninst\u271d\u2075 : Category.{u_2, u_1} D\ninst\u271d\u2074 : Abelian C\ninst\u271d\u00b3 : HasInjectiveResolutions C\ninst\u271d\u00b2 : Abelian D\nF G : C \u2964 D\ninst\u271d\u00b9 : Functor.Additive F\ninst\u271d : Functor.Additive G\n\u03b1 : F \u27f6 G\nX : C\nP : InjectiveResolution X\n\u03b2 : (injectiveResolution X).cocomplex \u27f6 P.cocomplex\nh\u03b2 : (HomotopyCategory.quotient C (ComplexShape.up \u2115)).map \u03b2 = (iso P).hom\n\u22a2 (HomotopyCategory.quotient D (ComplexShape.up \u2115)).map\n      ((NatTrans.mapHomologicalComplex \u03b1 (ComplexShape.up \u2115)).app ((injectiveResolutions C).obj X).as \u226b\n        (Functor.mapHomologicalComplex G (ComplexShape.up \u2115)).map \u03b2) =\n    (HomotopyCategory.quotient D (ComplexShape.up \u2115)).map\n      ((NatTrans.mapHomologicalComplex \u03b1 (ComplexShape.up \u2115)).app (injectiveResolution X).cocomplex \u226b\n        (Functor.mapHomologicalComplex G (ComplexShape.up \u2115)).map \u03b2)", "expanded_tactic": "rfl", "predictions0": ["rfl", "dsimp", "rw [h\u03b2]", "rw [\u2190 h\u03b2]", "simp only [\u2190 h\u03b2]", "simp only [\u2190 <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>]", "simp only [\u2190 <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>, h\u03b2]", "simp only [\u2190 <c> {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 f = h</c>]"], "predictions1": ["rfl", "rw [h\u03b2]", "rw [<a>Functor.map_comp</a>, <a>Functor.mapHomologicalComplex_naturality</a>, h\u03b2]", "simp only [<a>Functor.mapHomologicalComplex_obj_assoc</a>, <a>Functor.mapHomologicalComplex_obj_assoc</a>]", "simp only [<a>Functor.mapHomologicalComplex_obj_assoc</a>, <a>Functor.mapHomologicalComplex_obj_assoc</a>, <a>Functor.mapHomologicalComplex_obj_assoc</a>]", "simp only [<a>Functor.mapHomologicalComplex_naturality</a>, <a>Functor.mapHomologicalComplex_naturality</a>, <a>Functor.mapHomologicalComplex_naturality</a>]", "simp only [<a>Functor.mapHomologicalComplex_obj_assoc</a>, <a>Functor.mapHomologicalComplex_obj_assoc</a>, <a>Functor.mapHomologicalComplex_obj_assoc</a>,\n    <a>Functor.mapHomologicalComplex_obj_assoc</a>]", "simp only [<a>Functor.mapHomologicalComplex_obj_assoc</a>, <a>Functor.mapHomologicalComplex_obj_assoc</a>,\n    <a>Functor.mapHomologicalComplex_obj_assoc</a>, <a>Functor.mapHomologicalComplex_obj_assoc</a>]"], "predictions2": ["rfl", "rw [\u2190 <c> (\u03b1 : F \u27f6 G) [IsIso \u03b1] {f : Z \u27f6 Y} {g : Z \u27f6 X} : g = \u03b1.inv \u226b f \u2194 \u03b1.hom \u226b g = f</c>]", "rw [\u2190 <c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c>]", "rw [\u2190 <c> (\u03b1 : F \u27f6 G) [IsIso \u03b1] {f : X \u27f6 Z} {g : Y \u27f6 Z} : g = \u03b1.inv \u226b f \u2194 \u03b1.hom \u226b g = f</c>]", "rw [\u2190 <c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> ((<c> : C \u2964 D where\n  obj X</c> _).<a>map</a> \u03b2)]", "rw [\u2190 <c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> ((<c> : HomotopyCategory C \u2964 D where\n  obj X</c> _).<a>map</a> \u03b2)]", "rw [\u2190 <c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> ((<c> : HomotopyCategory C \u2964 D where\n  obj X</c> _).<a>hom</a> \u03b2)]", "rw [\u2190 <c> (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h</c> ((<c> : HomotopyCategory C \u2964 D where\n  obj X</c> _ _).<a>map</a> \u03b2)]"]}, {"state_before": "case refine_1.refine_2\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : FinitaryPreExtensive C\ninst\u271d : FinitaryExtensive C\nF : C\u1d52\u1d56 \u2964 Type (max u v)\nhF : \u2200 {X : C}, \u2200 R \u2208 (extensiveCoverage C).covering X, IsSheafFor F R\n\u03b1 : Type\nx\u271d : Fintype \u03b1\nK : Discrete \u03b1 \u2964 C\u1d52\u1d56\nZ : \u03b1 \u2192 C := fun i => (K.obj { as := i }).unop\nthis\u271d : hasPullbacks (ofArrows Z (Cofan.inj (Cofan.mk (\u2210 Z) (Sigma.\u03b9 Z))))\nthis : \u2200 (i : \u03b1), Mono (Cofan.inj (Cofan.mk (\u2210 Z) (Sigma.\u03b9 Z)) i)\ni : K \u2245 Discrete.functor fun i => op (Z i) := Discrete.natIsoFunctor\n\u22a2 (ofArrows Z fun i => Sigma.\u03b9 Z i) \u2208 (extensiveCoverage C).covering (\u2210 Z)", "expanded_tactic": "refine \u27e8\u03b1, <c> {\u03b1 : Sort u} [i : \u03b1] : \u03b1</c>, Z, (fun i \u21a6 <c> (f : \u03b2 \u2192 C) [HasCoproduct f] (b : \u03b2) : f b \u27f6 \u2210 f</c> Z i), <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, ?_\u27e9", "predictions0": ["exact \u27e8\u03b1, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9", "refine \u27e8\u03b1, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>,?_\u27e9", "refine \u27e8\u03b1, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9", "refine \u27e8K.obj \u27e8i, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9,?_\u27e9", "refine \u27e8<c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9", "refine \u27e8\u03b1, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, fun i =>?_\u27e9", "refine \u27e8\u03b1, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, fun i \u21a6?_\u27e9", "refine \u27e8K.obj \u27e8i, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9,?_,?_\u27e9"], "predictions1": ["exact \u27e8_, _, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9", "exact \u27e8_, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9", "exact \u27e8\u03b1, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9", "exact \u27e8_, _, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9", "refine \u27e8K.obj \u27e8i, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9,?_,?_\u27e9", "refine \u27e8K.obj \u27e8i, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9,?_\u27e9", "refine \u27e8K.obj \u27e8i, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9", "exact \u27e8_, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9"], "predictions2": ["exact \u27e8_, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9", "exact \u27e8_, _, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9", "exact <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "exact \u27e8_, _, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9", "exact \u27e8_, _, <c> {\u03b1 : Sort u} [i : \u03b1] : \u03b1</c>\u27e9", "exact \u27e8_, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>, <c> {\u03b1 : Sort u} [i : \u03b1] : \u03b1</c>\u27e9", "exact \u27e8_, <c> {\u03b1 : Sort u} [i : \u03b1] : \u03b1</c>, <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>\u27e9", "exact \u27e8_, <c> {\u03b1 : Sort u} [i : \u03b1] : \u03b1</c>, <c> {\u03b1 : Sort u} [i : \u03b1] : \u03b1</c>\u27e9"]}, {"state_before": "case pos\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : \u2115 \u2192 \u03b1\nbad : Set \u2115 := {m | \u2200 (n : \u2115), m < n \u2192 \u00acr (f m) (f n)}\nhbad : Set.Finite bad\nhe : (Set.Finite.toFinset hbad).Nonempty\n\u22a2 \u2203 m, \u2200 (n : \u2115), m \u2264 n \u2192 n \u2209 bad", "expanded_tactic": "refine'\n            \u27e8(hbad.toFinset.max' he).<a>succ</a>, fun n hn nbad =>\n              <c> : (n : Nat) \u2192 Not (LE.le (succ n) n)</c> _\n                (hn.trans (hbad.toFinset.le_max' n (hbad.mem_toFinset.2 nbad)))\u27e9", "predictions0": ["obtain \u27e8m, hm\u27e9 := he", "refine' \u27e8hbad.toFinset, fun n hn hmn => _\u27e9", "obtain \u27e8m, hm\u27e9 := <a>Finset.exists_maximal</a> he", "refine' \u27e8hbad.toFinset.toFinset, fun n hn hmn => _\u27e9", "obtain \u27e8m, hm\u27e9 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c>", "obtain \u27e8m, hm\u27e9 := <a>Finset.exists_mem_empty</a>.1 he", "obtain \u27e8m, hm\u27e9 := <c> {\u03b1 : Sort u} {a : \u03b1} : Eq a a</c> he", "obtain \u27e8m, hm\u27e9 := <a>Finset.exists_mem_empty</a> he"], "predictions1": ["obtain \u27e8m, hm\u27e9 := he", "refine' \u27e8hbad.toFinset, fun n hn hmn => _\u27e9", "refine' \u27e8hbad.toFinset, fun n hn hnb => _\u27e9", "refine' \u27e8hbad.toFinset.nonempty, fun n hn hnb => _\u27e9", "refine' \u27e8hbad.toFinset.nonempty, fun n hn hmn => _\u27e9", "refine' \u27e8hbad.toFinset.card, fun n hn hnb => _\u27e9", "refine' \u27e8hbad.toFinset.card, fun m hmn hnm => _\u27e9", "refine' \u27e8hbad.toFinset.nonempty, fun m hmn hnm => _\u27e9"], "predictions2": ["refine' \u27e8hbad.toFinset.card, fun m hm hmn => _\u27e9", "refine' \u27e8hbad.toFinset, fun m hm hmn => _\u27e9", "refine' \u27e8hbad.toFinset, fun m hmn hnm => _\u27e9", "refine' \u27e8hbad.toFinset.card, fun m hmn hnm => _\u27e9", "obtain \u27e8m, hm\u27e9 := he", "refine' \u27e8hbad.toFinset.card, fun m hm hnm => _\u27e9", "obtain \u27e8m, hm\u27e9 := <c> {s : Finset \u03b1} : s.Nonempty \u2194 s \u2260 \u2205</c>.1 he", "obtain \u27e8m, hm\u27e9 := <c> {s : Finset \u03b1} : s.Nonempty \u2194 s = \u2205</c>.1 he"]}, {"state_before": "case intro.intro.intro.intro.intro\nC : Type u_1\nD : Type u_2\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Category.{?u.26836, u_2} D\nW : MorphismProperty C\nX Y : C\nz\u2081 z\u2082 z\u2083 : LeftFraction W X Y\ninst\u271d : HasLeftCalculusOfFractions W\nh\u2082\u2083 : LeftFractionRel z\u2082 z\u2083\nZ\u2084 : C\nt\u2081 : z\u2081.Y' \u27f6 Z\u2084\nt\u2082 : z\u2082.Y' \u27f6 Z\u2084\nhst : z\u2081.s \u226b t\u2081 = z\u2082.s \u226b t\u2082\nhft : z\u2081.f \u226b t\u2081 = z\u2082.f \u226b t\u2082\nht : W (z\u2081.s \u226b t\u2081)\n\u22a2 LeftFractionRel z\u2081 z\u2083", "expanded_tactic": "obtain \u27e8Z\u2085, u\u2082, u\u2083, hsu, hfu, hu\u27e9 := h\u2082\u2083", "predictions0": ["obtain \u27e8Z\u2085, t\u2081, hst\u27e9 := h\u2082\u2083", "obtain \u27e8Z\u2085, t\u2082, hst\u27e9 := h\u2082\u2083", "obtain \u27e8Z\u2085, t\u2081, t\u2082, ht\u27e9 := h\u2082\u2083", "rcases h\u2082\u2083 with \u27e8Z\u2084, t\u2083, ht\u27e9", "rcases h\u2082\u2083 with \u27e8Z\u2085, t\u2081, hst\u27e9", "rcases h\u2082\u2083 with \u27e8Z\u2085, t\u2081, t\u2082, ht\u27e9", "rcases h\u2082\u2083 with \u27e8Z\u2085, t\u2083, ht\u27e9", "rcases h\u2082\u2083 with \u27e8Z\u2085, t\u2081, t\u2082, hst\u27e9"], "predictions1": ["obtain \u27e8Z\u2085, rfl\u27e9 := h\u2082\u2083", "obtain \u27e8Z\u2085, h\u2082\u2083\u27e9 := h\u2082\u2083", "obtain \u27e8Z\u2085, t\u2082, ht\u27e9 := h\u2082\u2083", "rcases h\u2082\u2083 with \u27e8Z\u2085, t\u2081, t\u2082, ht\u27e9", "rcases h\u2082\u2083 with \u27e8Z\u2085, t\u2081', t\u2082', ht\u27e9", "obtain \u27e8Z\u2085, t\u2081', t\u2082', hst', hft', ht'\u27e9 := h\u2082\u2083", "obtain \u27e8Z\u2085, t\u2081', t\u2082', hst', ht'\u27e9 := h\u2082\u2083", "rcases h\u2082\u2083 with \u27e8Z\u2085, t\u2081', t\u2082', hst', hft'\u27e9"], "predictions2": ["obtain \u27e8Z\u2085, h\u2081\u27e9 := h\u2082\u2083", "obtain \u27e8Z\u2085, h\u2082\u27e9 := h\u2082\u2083", "obtain \u27e8Z\u2085, rfl\u27e9 := h\u2082\u2083", "obtain \u27e8Z\u2085, t\u2082, rfl\u27e9 := h\u2082\u2083", "obtain \u27e8Z\u2085, u\u2082, h\u2082\u27e9 := h\u2082\u2083", "obtain \u27e8Z\u2085, u\u2082, h\u2082, h\u2083\u27e9 := h\u2082\u2083", "obtain \u27e8Z\u2085, u\u2082, hu\u2082, h\u2083\u27e9 := h\u2082\u2083", "obtain \u27e8Z\u2085, t\u2082, rfl\u27e9 := <c> {W : MorphismProperty C} (t : W.LeftFraction X Y)\n    (h : W.LeftFraction X Y) : \u2203 (Z : C) (f : X \u27f6 Z) (g : Y \u27f6 Z), t.f \u226b g = t.f \u226b"]}, {"state_before": "C : Type u\ninst\u271d\u2074 : Category.{v, u} C\ninst\u271d\u00b3 : HasZeroObject C\ninst\u271d\u00b2 : HasShift C \u2124\ninst\u271d\u00b9 : Preadditive C\ninst\u271d : \u2200 (n : \u2124), Functor.Additive (shiftFunctor C n)\nhC : Pretriangulated C\nT T' : Triangle C\n\u03c6 : T \u27f6 T'\nhT : T \u2208 distinguishedTriangles\nhT' : T' \u2208 distinguishedTriangles\nh\u2081 : IsIso \u03c6.hom\u2081\nh\u2083 : IsIso \u03c6.hom\u2083\nthis : Mono \u03c6.hom\u2082\nA : C\ny\u2082 : A \u27f6 T'.obj\u2082\nx\u2083 : A \u27f6 T.obj\u2083\nhx\u2083 : x\u2083 \u226b \u03c6.hom\u2083 = y\u2082 \u226b T'.mor\u2082\nx\u2082 : A \u27f6 T.obj\u2082\nhx\u2082 : x\u2083 = x\u2082 \u226b T.mor\u2082\ny\u2081 : A \u27f6 T'.obj\u2081\nhy\u2081 : y\u2082 - x\u2082 \u226b \u03c6.hom\u2082 = y\u2081 \u226b T'.mor\u2081\n\u22a2 (y\u2081 \u226b inv \u03c6.hom\u2081) \u226b \u03c6.hom\u2081 = y\u2081", "expanded_tactic": "simp", "predictions0": ["simp", "simp only [<a>Category.assoc</a>, <a>inv_hom_id</a>, <a>Category.comp_id</a>]", "simp [<a>Category.assoc</a>]", "simp only [<a>Category.assoc</a>, <a>Category.comp_id</a>]", "simp only [<a>Category.assoc</a>]", "simp only [<a>Category.assoc</a>, <a>Category.comp_id</a>, <a>Category.id_comp</a>]", "simp only [<a>Category.assoc</a>, <a>Category.comp_id</a>, <a>Category.assoc</a>]", "simp only [<a>Category.assoc</a>, <a>inv_comp</a>, <a>Category.comp_id</a>]"], "predictions1": ["simp only [<a>Category.assoc</a>, <a>inv_hom_id</a>, <a>Category.comp_id</a>]", "simp [<c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> \u03c6.hom\u2081]", "simp only [<c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c>]", "simp [<c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c>]", "simp only [<a>Category.assoc</a>, <c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c>]", "simp only [<a>Category.assoc</a>, <a>inv</a>, <a>Category.comp_id</a>]", "simp", "simp [<c> (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h</c> \u03c6.hom\u2082]"], "predictions2": ["simp only [<c> (\u03b1 : X \u27f6 Y) [IsIso \u03b1] {f : X \u27f6 Z} {g : Y \u27f6 Z} : inv \u03b1 \u226b f = g \u2194 f = \u03b1 \u226b g</c>]", "simp only [<a>Category.assoc</a>, <c> (f : X \u27f6 Y) [I : IsIso f] : inv f \u226b f = \ud835\udfd9 X</c>, \u03c6.comm\u2081]", "simp only [<a>Category.assoc</a>, <c> (f : X \u27f6 Y) [I : IsIso f] : inv f \u226b f = \ud835\udfd9 X</c>, <a>id_comp</a>]", "simp only [<a>Category.assoc</a>, \u2190 \u03c6.comm\u2081\u2082, <c> (X : C) {Y\u2081 Y\u2082 : C} (f : Y\u2081 \u27f6 Y\u2082) :\n    \ud835\udfd9 X = f", "simp only [<c> (\u03b1 : X \u27f6 Y) [IsIso \u03b1] {f : X \u27f6 Z} {g : Y \u27f6 Z} : inv \u03b1 \u226b f = g \u2194 f = \u03b1 \u226b g</c>, <a>id_comp</a>]", "simp only [<c> (\u03b1 : X \u27f6 Y) [IsIso \u03b1] {f : X \u27f6 Z} {g : Y \u27f6 Z} : inv \u03b1 \u226b f = g \u2194 f = \u03b1 \u226b g</c>, \u03c6.comm\u2081]", "simp only [<a>Category.assoc</a>, \u2190 \u03c6.comm\u2081\u2082, <c> (X : C) {Y\u2081 Y\u2082 : C} (f : Y\u2081 \u27f6 Y\u2082) :\n    \ud835\udfd9 X = f</c>]", "simp only [<c> (\u03b1 : X \u27f6 Y) [IsIso \u03b1] {f : X \u27f6 Z} {g : Y \u27f6 Z} : inv \u03b1 \u226b f = g \u2194 f = \u03b1 \u226b g</c>, <a>assoc</a>]"]}]